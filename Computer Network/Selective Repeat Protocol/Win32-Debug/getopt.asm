; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

	TITLE	D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\Win32-Debug\getopt.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_optarg
PUBLIC	_optind
PUBLIC	_opterr
PUBLIC	_optopt
_BSS	SEGMENT
_optarg	DD	01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__32FB09EA_concurrencysal@h DB 01H
__92642135_sal@h DB 01H
__91763366_vadefs@h DB 01H
__53563FEE_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__CDDAF8CA_errno@h DB 01H
__1AB1F8E3_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__570D733F_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__1AC1E0A0_getopt@h DB 01H
__8D133928_getopt@c DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
_optind	DD	01H
_opterr	DD	01H
_optopt	DD	03fH
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_getopt_int
PUBLIC	_getopt_int_only
PUBLIC	__getopt_internal
PUBLIC	_getopt
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@		; `string'
PUBLIC	??_C@_02BAABKJLB@?9?9@				; `string'
PUBLIC	??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@ ; `string'
PUBLIC	??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@ ; `string'
PUBLIC	??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@ ; `string'
PUBLIC	??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@ ; `string'
PUBLIC	??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@ ; `string'
PUBLIC	??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@ ; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_strchr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__getenv:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_nextchar DD	01H DUP (?)
___getopt_initialized DD 01H DUP (?)
_ordering DD	01H DUP (?)
_first_nonopt DD 01H DUP (?)
_last_nonopt DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@
CONST	SEGMENT
??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@ DB '%s: option'
	DB	' requires an argument -- %c', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@
CONST	SEGMENT
??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@ DB '%s: illeg'
	DB	'al option -- %c', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@ DB '%'
	DB	's: unrecognized option `%c%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@ DB '%'
	DB	's: unrecognized option `--%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@
CONST	SEGMENT
??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@ DB '%'
	DB	's: option `%s'' requires an argument', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@
CONST	SEGMENT
??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@ DB 09H
	DB	09H, 09H, 09H, 09H, '%s: option `%c%s'' doesn''t allow an argu'
	DB	'ment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@
CONST	SEGMENT
??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@ DB 09H
	DB	09H, 09H, 09H, 09H, '%s: option `--%s'' doesn''t allow an argu'
	DB	'ment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@
CONST	SEGMENT
??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@ DB '%s:'
	DB	' option `%s'' is ambiguous', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9@ DB '--', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
CONST	SEGMENT
??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@ DB 'POSIXLY_CORRECT', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\getopt.c
;	COMDAT __getopt_initialize
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_optstring$ = 16					; size = 4
__getopt_initialize PROC				; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8D133928_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 226  :     /* Start processing options with ARGV-element 1 (since ARGV-element 0
; 227  :        is the program name); the sequence of previously skipped
; 228  :        non-option ARGV-elements is empty.  */
; 229  : 
; 230  :     first_nonopt = last_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _last_nonopt, eax
	mov	ecx, DWORD PTR _last_nonopt
	mov	DWORD PTR _first_nonopt, ecx

; 231  : 
; 232  :     nextchar = NULL;

	mov	DWORD PTR _nextchar, 0

; 233  : 
; 234  :     /* Determine how to handle the ordering of options and nonoptions.  */
; 235  : 
; 236  :     if (optstring[0] == '-')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optstring$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN2@getopt_ini

; 237  :     {
; 238  : 	ordering = RETURN_IN_ORDER;

	mov	DWORD PTR _ordering, 2

; 239  : 	++optstring;

	mov	eax, DWORD PTR _optstring$[ebp]
	add	eax, 1
	mov	DWORD PTR _optstring$[ebp], eax

; 240  :     }

	jmp	SHORT $LN3@getopt_ini
$LN2@getopt_ini:

; 241  :     else if (optstring[0] == '+')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optstring$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN4@getopt_ini

; 242  :     {
; 243  : 	ordering = REQUIRE_ORDER;

	mov	DWORD PTR _ordering, 0

; 244  : 	++optstring;

	mov	eax, DWORD PTR _optstring$[ebp]
	add	eax, 1
	mov	DWORD PTR _optstring$[ebp], eax

; 245  :     }

	jmp	SHORT $LN3@getopt_ini
$LN4@getopt_ini:

; 246  :     else if (getenv ("POSIXLY_CORRECT") != NULL)

	mov	esi, esp
	push	OFFSET ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN6@getopt_ini

; 247  : 	ordering = REQUIRE_ORDER;

	mov	DWORD PTR _ordering, 0
	jmp	SHORT $LN3@getopt_ini
$LN6@getopt_ini:

; 248  :     else
; 249  : 	ordering = PERMUTE;

	mov	DWORD PTR _ordering, 1
$LN3@getopt_ini:

; 250  : 
; 251  :     return optstring;

	mov	eax, DWORD PTR _optstring$[ebp]

; 252  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__getopt_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\getopt.c
;	COMDAT _exchange
_TEXT	SEGMENT
_i$1 = -92						; size = 4
_len$2 = -80						; size = 4
_i$3 = -68						; size = 4
_len$4 = -56						; size = 4
_tem$ = -44						; size = 4
_top$ = -32						; size = 4
_middle$ = -20						; size = 4
_bottom$ = -8						; size = 4
_argv$ = 8						; size = 4
_exchange PROC						; COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8D133928_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 170  :     int bottom = first_nonopt;

	mov	eax, DWORD PTR _first_nonopt
	mov	DWORD PTR _bottom$[ebp], eax

; 171  :     int middle = last_nonopt;

	mov	eax, DWORD PTR _last_nonopt
	mov	DWORD PTR _middle$[ebp], eax

; 172  :     int top = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _top$[ebp], eax
$LN2@exchange:

; 173  :     char *tem;
; 174  : 
; 175  :     /* Exchange the shorter segment with the far end of the inter segment.
; 176  :        That puts the shorter segment into the right place.
; 177  :        It leaves the inter segment in the right place overall,
; 178  :        but it consists of two parts that need to be swapped next.  */
; 179  : 
; 180  :     while (top > middle && middle > bottom)

	mov	eax, DWORD PTR _top$[ebp]
	cmp	eax, DWORD PTR _middle$[ebp]
	jle	$LN3@exchange
	mov	eax, DWORD PTR _middle$[ebp]
	cmp	eax, DWORD PTR _bottom$[ebp]
	jle	$LN3@exchange

; 181  :     {
; 182  : 	if (top - middle > middle - bottom)

	mov	eax, DWORD PTR _top$[ebp]
	sub	eax, DWORD PTR _middle$[ebp]
	mov	ecx, DWORD PTR _middle$[ebp]
	sub	ecx, DWORD PTR _bottom$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN10@exchange

; 183  : 	{
; 184  : 	    /* Bottom segment is the short one.  */
; 185  : 	    int len = middle - bottom;

	mov	eax, DWORD PTR _middle$[ebp]
	sub	eax, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR _len$4[ebp], eax

; 186  : 	    register int i;
; 187  : 
; 188  : 	    /* Swap it with the top part of the top segment.  */
; 189  : 	    for (i = 0; i < len; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@exchange
$LN4@exchange:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@exchange:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _len$4[ebp]
	jge	SHORT $LN5@exchange

; 190  : 	    {
; 191  : 		tem = argv[bottom + i];

	mov	eax, DWORD PTR _bottom$[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tem$[ebp], edx

; 192  : 		argv[bottom + i] = argv[top - (middle - bottom) + i];

	mov	eax, DWORD PTR _middle$[ebp]
	sub	eax, DWORD PTR _bottom$[ebp]
	mov	ecx, DWORD PTR _top$[ebp]
	sub	ecx, eax
	add	ecx, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _bottom$[ebp]
	add	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	esi, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 193  : 		argv[top - (middle - bottom) + i] = tem;

	mov	eax, DWORD PTR _middle$[ebp]
	sub	eax, DWORD PTR _bottom$[ebp]
	mov	ecx, DWORD PTR _top$[ebp]
	sub	ecx, eax
	add	ecx, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR _tem$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 194  : 	    }

	jmp	SHORT $LN4@exchange
$LN5@exchange:

; 195  : 	    /* Exclude the moved bottom segment from further swapping.  */
; 196  : 	    top -= len;

	mov	eax, DWORD PTR _top$[ebp]
	sub	eax, DWORD PTR _len$4[ebp]
	mov	DWORD PTR _top$[ebp], eax

; 197  : 	}

	jmp	SHORT $LN11@exchange
$LN10@exchange:

; 198  : 	else
; 199  : 	{
; 200  : 	    /* Top segment is the short one.  */
; 201  : 	    int len = top - middle;

	mov	eax, DWORD PTR _top$[ebp]
	sub	eax, DWORD PTR _middle$[ebp]
	mov	DWORD PTR _len$2[ebp], eax

; 202  : 	    register int i;
; 203  : 
; 204  : 	    /* Swap it with the bottom part of the bottom segment.  */
; 205  : 	    for (i = 0; i < len; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN9@exchange
$LN7@exchange:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN9@exchange:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _len$2[ebp]
	jge	SHORT $LN8@exchange

; 206  : 	    {
; 207  : 		tem = argv[bottom + i];

	mov	eax, DWORD PTR _bottom$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tem$[ebp], edx

; 208  : 		argv[bottom + i] = argv[middle + i];

	mov	eax, DWORD PTR _middle$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _bottom$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	esi, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 209  : 		argv[middle + i] = tem;

	mov	eax, DWORD PTR _middle$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR _tem$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 210  : 	    }

	jmp	SHORT $LN7@exchange
$LN8@exchange:

; 211  : 	    /* Exclude the moved top segment from further swapping.  */
; 212  : 	    bottom += len;

	mov	eax, DWORD PTR _bottom$[ebp]
	add	eax, DWORD PTR _len$2[ebp]
	mov	DWORD PTR _bottom$[ebp], eax
$LN11@exchange:

; 213  : 	}
; 214  :     }

	jmp	$LN2@exchange
$LN3@exchange:

; 215  : 
; 216  :     /* Update records for the slots the non-options now occupy.  */
; 217  : 
; 218  :     first_nonopt += (optind - last_nonopt);

	mov	eax, DWORD PTR _optind
	sub	eax, DWORD PTR _last_nonopt
	add	eax, DWORD PTR _first_nonopt
	mov	DWORD PTR _first_nonopt, eax

; 219  :     last_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _last_nonopt, eax

; 220  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_exchange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\getopt.c
;	COMDAT _getopt
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_optstring$ = 16					; size = 4
_getopt	PROC						; COMDAT

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8D133928_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 785  :     return _getopt_internal (argc, argv, optstring,

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _optstring$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argc$[ebp]
	push	edx
	call	__getopt_internal
	add	esp, 24					; 00000018H

; 786  : 	    (const struct option *) 0, (int *) 0, 0);
; 787  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getopt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\getopt.c
;	COMDAT __getopt_internal
_TEXT	SEGMENT
tv316 = -316						; size = 4
tv172 = -316						; size = 4
_temp$1 = -116						; size = 4
_c$2 = -101						; size = 1
_option_index$3 = -92					; size = 4
_indfound$4 = -80					; size = 4
_ambig$5 = -68						; size = 4
_exact$6 = -56						; size = 4
_pfound$7 = -44						; size = 4
_p$8 = -32						; size = 4
_nameend$9 = -20					; size = 4
_print_errors$ = -8					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_optstring$ = 16					; size = 4
_intopts$ = 20						; size = 4
_intind$ = 24						; size = 4
_int_only$ = 28						; size = 4
__getopt_internal PROC					; COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 31					; 0000001fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8D133928_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 313  :     int print_errors = opterr;

	mov	eax, DWORD PTR _opterr
	mov	DWORD PTR _print_errors$[ebp], eax

; 314  :     if (optstring[0] == ':')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optstring$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN10@getopt_int

; 315  : 	print_errors = 0;

	mov	DWORD PTR _print_errors$[ebp], 0
$LN10@getopt_int:

; 316  : 
; 317  :     if (argc < 1)

	cmp	DWORD PTR _argc$[ebp], 1
	jge	SHORT $LN11@getopt_int

; 318  : 	return -1;

	or	eax, -1
	jmp	$LN1@getopt_int
$LN11@getopt_int:

; 319  : 
; 320  :     optarg = NULL;

	mov	DWORD PTR _optarg, 0

; 321  : 
; 322  :     if (optind == 0 || !__getopt_initialized)

	cmp	DWORD PTR _optind, 0
	je	SHORT $LN13@getopt_int
	cmp	DWORD PTR ___getopt_initialized, 0
	jne	SHORT $LN12@getopt_int
$LN13@getopt_int:

; 323  :     {
; 324  : 	if (optind == 0)

	cmp	DWORD PTR _optind, 0
	jne	SHORT $LN14@getopt_int

; 325  : 	    optind = 1;	/* Don't scan ARGV[0], the program name.  */

	mov	DWORD PTR _optind, 1
$LN14@getopt_int:

; 326  : 	optstring = _getopt_initialize (argc, argv, optstring);

	mov	eax, DWORD PTR _optstring$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argc$[ebp]
	push	edx
	call	__getopt_initialize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _optstring$[ebp], eax

; 327  : 	__getopt_initialized = 1;

	mov	DWORD PTR ___getopt_initialized, 1
$LN12@getopt_int:

; 328  :     }
; 329  : 
; 330  :     /* Test whether ARGV[optind] points to a non-option argument.
; 331  :        Either it does not have option syntax, or there is an environment flag
; 332  :        from the shell indicating it is not an option.  The later information
; 333  :        is only used when the used in the GNU libc.  */
; 334  : #define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
; 335  : 
; 336  :     if (nextchar == NULL || *nextchar == '\0')

	cmp	DWORD PTR _nextchar, 0
	je	SHORT $LN16@getopt_int
	mov	eax, DWORD PTR _nextchar
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN15@getopt_int
$LN16@getopt_int:

; 337  :     {
; 338  : 	/* Advance to the next ARGV-element.  */
; 339  : 
; 340  : 	/* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
; 341  : 	   moved back by the user (who may also have changed the arguments).  */
; 342  : 	if (last_nonopt > optind)

	mov	eax, DWORD PTR _last_nonopt
	cmp	eax, DWORD PTR _optind
	jle	SHORT $LN17@getopt_int

; 343  : 	    last_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _last_nonopt, eax
$LN17@getopt_int:

; 344  : 	if (first_nonopt > optind)

	mov	eax, DWORD PTR _first_nonopt
	cmp	eax, DWORD PTR _optind
	jle	SHORT $LN18@getopt_int

; 345  : 	    first_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _first_nonopt, eax
$LN18@getopt_int:

; 346  : 
; 347  : 	if (ordering == PERMUTE)

	cmp	DWORD PTR _ordering, 1
	jne	$LN19@getopt_int

; 348  : 	{
; 349  : 	    /* If we have just processed some options following some non-options,
; 350  : 	       exchange them so that the options come first.  */
; 351  : 
; 352  : 	    if (first_nonopt != last_nonopt && last_nonopt != optind)

	mov	eax, DWORD PTR _first_nonopt
	cmp	eax, DWORD PTR _last_nonopt
	je	SHORT $LN20@getopt_int
	mov	eax, DWORD PTR _last_nonopt
	cmp	eax, DWORD PTR _optind
	je	SHORT $LN20@getopt_int

; 353  : 		exchange ((char **) argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	_exchange
	add	esp, 4
	jmp	SHORT $LN2@getopt_int
$LN20@getopt_int:

; 354  : 	    else if (last_nonopt != optind)

	mov	eax, DWORD PTR _last_nonopt
	cmp	eax, DWORD PTR _optind
	je	SHORT $LN2@getopt_int

; 355  : 		first_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _first_nonopt, eax
$LN2@getopt_int:

; 356  : 
; 357  : 	    /* Skip any additional non-options
; 358  : 	       and extend the range of non-options previously skipped.  */
; 359  : 
; 360  : 	    while (optind < argc && NONOPTION_P)

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _argc$[ebp]
	jge	SHORT $LN3@getopt_int
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optind
	mov	eax, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN23@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN3@getopt_int
$LN23@getopt_int:

; 361  : 		optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
	jmp	SHORT $LN2@getopt_int
$LN3@getopt_int:

; 362  : 	    last_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _last_nonopt, eax
$LN19@getopt_int:

; 363  : 	}
; 364  : 
; 365  : 	/* The special ARGV-element `--' means premature end of options.
; 366  : 	   Skip it like a null option,
; 367  : 	   then exchange with previous non-options as if it were an option,
; 368  : 	   then skip everything else like a non-option.  */
; 369  : 
; 370  : 	if (optind != argc && !strcmp (argv[optind], "--"))

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _argc$[ebp]
	je	SHORT $LN24@getopt_int
	push	OFFSET ??_C@_02BAABKJLB@?9?9@
	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@getopt_int

; 371  : 	{
; 372  : 	    optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 373  : 
; 374  : 	    if (first_nonopt != last_nonopt && last_nonopt != optind)

	mov	eax, DWORD PTR _first_nonopt
	cmp	eax, DWORD PTR _last_nonopt
	je	SHORT $LN25@getopt_int
	mov	eax, DWORD PTR _last_nonopt
	cmp	eax, DWORD PTR _optind
	je	SHORT $LN25@getopt_int

; 375  : 		exchange ((char **) argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	_exchange
	add	esp, 4
	jmp	SHORT $LN26@getopt_int
$LN25@getopt_int:

; 376  : 	    else if (first_nonopt == last_nonopt)

	mov	eax, DWORD PTR _first_nonopt
	cmp	eax, DWORD PTR _last_nonopt
	jne	SHORT $LN26@getopt_int

; 377  : 		first_nonopt = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _first_nonopt, eax
$LN26@getopt_int:

; 378  : 	    last_nonopt = argc;

	mov	eax, DWORD PTR _argc$[ebp]
	mov	DWORD PTR _last_nonopt, eax

; 379  : 
; 380  : 	    optind = argc;

	mov	eax, DWORD PTR _argc$[ebp]
	mov	DWORD PTR _optind, eax
$LN24@getopt_int:

; 381  : 	}
; 382  : 
; 383  : 	/* If we have done all the ARGV-elements, stop the scan
; 384  : 	   and back over any non-options that we skipped and permuted.  */
; 385  : 
; 386  : 	if (optind == argc)

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _argc$[ebp]
	jne	SHORT $LN28@getopt_int

; 387  : 	{
; 388  : 	    /* Set the next-arg-index to point at the non-options
; 389  : 	       that we previously skipped, so the caller will digest them.  */
; 390  : 	    if (first_nonopt != last_nonopt)

	mov	eax, DWORD PTR _first_nonopt
	cmp	eax, DWORD PTR _last_nonopt
	je	SHORT $LN29@getopt_int

; 391  : 		optind = first_nonopt;

	mov	eax, DWORD PTR _first_nonopt
	mov	DWORD PTR _optind, eax
$LN29@getopt_int:

; 392  : 	    return -1;

	or	eax, -1
	jmp	$LN1@getopt_int
$LN28@getopt_int:

; 393  : 	}
; 394  : 
; 395  : 	/* If we have come to a non-option and did not permute it,
; 396  : 	   either stop the scan or describe it to the caller and pass it by.  */
; 397  : 
; 398  : 	if (NONOPTION_P)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optind
	mov	eax, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN31@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN30@getopt_int
$LN31@getopt_int:

; 399  : 	{
; 400  : 	    if (ordering == REQUIRE_ORDER)

	cmp	DWORD PTR _ordering, 0
	jne	SHORT $LN32@getopt_int

; 401  : 		return -1;

	or	eax, -1
	jmp	$LN1@getopt_int
$LN32@getopt_int:

; 402  : 	    optarg = argv[optind++];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _optarg, edx
	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 403  : 	    return 1;

	mov	eax, 1
	jmp	$LN1@getopt_int
$LN30@getopt_int:

; 404  : 	}
; 405  : 
; 406  : 	/* We have found another option-ARGV-element.
; 407  : 	   Skip the initial punctuation.  */
; 408  : 
; 409  : 	nextchar = (argv[optind] + 1

	cmp	DWORD PTR _intopts$[ebp], 0
	je	SHORT $LN81@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN81@getopt_int
	mov	DWORD PTR tv172[ebp], 1
	jmp	SHORT $LN82@getopt_int
$LN81@getopt_int:
	mov	DWORD PTR tv172[ebp], 0
$LN82@getopt_int:
	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR tv172[ebp]
	lea	ecx, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _nextchar, ecx
$LN15@getopt_int:

; 410  : 		+ (intopts != NULL && argv[optind][1] == '-'));
; 411  :     }
; 412  : 
; 413  :     /* Decode the current option-ARGV-element.  */
; 414  : 
; 415  :     /* Check whether the ARGV-element is a int option.
; 416  : 
; 417  :        If int_only and the ARGV-element has the form "-f", where f is
; 418  :        a valid short option, don't consider it an abbreviated form of
; 419  :        a int option that starts with f.  Otherwise there would be no
; 420  :        way to give the -f short option.
; 421  : 
; 422  :        On the other hand, if there's a int option "fubar" and
; 423  :        the ARGV-element is "-fu", do consider that an abbreviation of
; 424  :        the int option, just like "--fu", and not "-f" with arg "u".
; 425  : 
; 426  :        This distinction seems to be the most useful approach.  */
; 427  : 
; 428  :     if (intopts != NULL
; 429  : 	    && (argv[optind][1] == '-'

	cmp	DWORD PTR _intopts$[ebp], 0
	je	$LN33@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN34@getopt_int
	cmp	DWORD PTR _int_only$[ebp], 0
	je	$LN33@getopt_int
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN34@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _optstring$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	$LN33@getopt_int
$LN34@getopt_int:

; 430  : 		|| (int_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
; 431  :     {
; 432  : 	char *nameend;
; 433  : 	const struct option *p;
; 434  : 	const struct option *pfound = NULL;

	mov	DWORD PTR _pfound$7[ebp], 0

; 435  : 	int exact = 0;

	mov	DWORD PTR _exact$6[ebp], 0

; 436  : 	int ambig = 0;

	mov	DWORD PTR _ambig$5[ebp], 0

; 437  : 	int indfound = -1;

	mov	DWORD PTR _indfound$4[ebp], -1

; 438  : 	int option_index;
; 439  : 
; 440  : 	for (nameend = nextchar; *nameend && *nameend != '='; nameend++)

	mov	eax, DWORD PTR _nextchar
	mov	DWORD PTR _nameend$9[ebp], eax
	jmp	SHORT $LN6@getopt_int
$LN4@getopt_int:
	mov	eax, DWORD PTR _nameend$9[ebp]
	add	eax, 1
	mov	DWORD PTR _nameend$9[ebp], eax
$LN6@getopt_int:
	mov	eax, DWORD PTR _nameend$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@getopt_int
	mov	eax, DWORD PTR _nameend$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN5@getopt_int

; 441  : 	    /* Do nothing.  */ ;

	jmp	SHORT $LN4@getopt_int
$LN5@getopt_int:

; 442  : 
; 443  : 	/* Test all int options for either exact match
; 444  : 	   or abbreviated matches.  */
; 445  : 	for (p = intopts, option_index = 0; p->name; p++, option_index++)

	mov	eax, DWORD PTR _intopts$[ebp]
	mov	DWORD PTR _p$8[ebp], eax
	mov	DWORD PTR _option_index$3[ebp], 0
	jmp	SHORT $LN9@getopt_int
$LN7@getopt_int:
	mov	eax, DWORD PTR _p$8[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _p$8[ebp], eax
	mov	ecx, DWORD PTR _option_index$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _option_index$3[ebp], ecx
$LN9@getopt_int:
	mov	eax, DWORD PTR _p$8[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN8@getopt_int

; 446  : 	    if (!strncmp (p->name, nextchar, nameend - nextchar))

	mov	eax, DWORD PTR _nameend$9[ebp]
	sub	eax, DWORD PTR _nextchar
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _nextchar
	push	ecx
	mov	edx, DWORD PTR _p$8[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN36@getopt_int

; 447  : 	    {
; 448  : 		if ((unsigned int) (nameend - nextchar)
; 449  : 			== (unsigned int) strlen (p->name))

	mov	esi, DWORD PTR _nameend$9[ebp]
	sub	esi, DWORD PTR _nextchar
	mov	eax, DWORD PTR _p$8[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LN37@getopt_int

; 450  : 		{
; 451  : 		    /* Exact match found.  */
; 452  : 		    pfound = p;

	mov	eax, DWORD PTR _p$8[ebp]
	mov	DWORD PTR _pfound$7[ebp], eax

; 453  : 		    indfound = option_index;

	mov	eax, DWORD PTR _option_index$3[ebp]
	mov	DWORD PTR _indfound$4[ebp], eax

; 454  : 		    exact = 1;

	mov	DWORD PTR _exact$6[ebp], 1

; 455  : 		    break;

	jmp	SHORT $LN8@getopt_int

; 456  : 		}

	jmp	SHORT $LN36@getopt_int
$LN37@getopt_int:

; 457  : 		else if (pfound == NULL)

	cmp	DWORD PTR _pfound$7[ebp], 0
	jne	SHORT $LN39@getopt_int

; 458  : 		{
; 459  : 		    /* First nonexact match found.  */
; 460  : 		    pfound = p;

	mov	eax, DWORD PTR _p$8[ebp]
	mov	DWORD PTR _pfound$7[ebp], eax

; 461  : 		    indfound = option_index;

	mov	eax, DWORD PTR _option_index$3[ebp]
	mov	DWORD PTR _indfound$4[ebp], eax

; 462  : 		}

	jmp	SHORT $LN36@getopt_int
$LN39@getopt_int:

; 463  : 		else if (int_only
; 464  : 			|| pfound->has_arg != p->has_arg
; 465  : 			|| pfound->flag != p->flag
; 466  : 			|| pfound->val != p->val)

	cmp	DWORD PTR _int_only$[ebp], 0
	jne	SHORT $LN42@getopt_int
	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR _p$8[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN42@getopt_int
	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR _p$8[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN42@getopt_int
	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR _p$8[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN36@getopt_int
$LN42@getopt_int:

; 467  : 		    /* Second or later nonexact match found.  */
; 468  : 		    ambig = 1;

	mov	DWORD PTR _ambig$5[ebp], 1
$LN36@getopt_int:

; 469  : 	    }

	jmp	$LN7@getopt_int
$LN8@getopt_int:

; 470  : 
; 471  : 	if (ambig && !exact)

	cmp	DWORD PTR _ambig$5[ebp], 0
	je	$LN43@getopt_int
	cmp	DWORD PTR _exact$6[ebp], 0
	jne	SHORT $LN43@getopt_int

; 472  : 	{
; 473  : 	    if (print_errors)

	cmp	DWORD PTR _print_errors$[ebp], 0
	je	SHORT $LN44@getopt_int

; 474  : 	    {
; 475  : 		fprintf (stderr, _("%s: option `%s' is ambiguous\n"),

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN44@getopt_int:

; 476  : 			argv[0], argv[optind]);
; 477  : 	    }
; 478  : 	    nextchar += strlen (nextchar);

	mov	eax, DWORD PTR _nextchar
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _nextchar
	mov	DWORD PTR _nextchar, eax

; 479  : 	    optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 480  : 	    optopt = 0;

	mov	DWORD PTR _optopt, 0

; 481  : 	    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN43@getopt_int:

; 482  : 	}
; 483  : 
; 484  : 	if (pfound != NULL)

	cmp	DWORD PTR _pfound$7[ebp], 0
	je	$LN45@getopt_int

; 485  : 	{
; 486  : 	    option_index = indfound;

	mov	eax, DWORD PTR _indfound$4[ebp]
	mov	DWORD PTR _option_index$3[ebp], eax

; 487  : 	    optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 488  : 	    if (*nameend)

	mov	eax, DWORD PTR _nameend$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN46@getopt_int

; 489  : 	    {
; 490  : 		/* Don't test has_arg with >, because some C compilers don't
; 491  : 		   allow it to be used on enums.  */
; 492  : 		if (pfound->has_arg)

	mov	eax, DWORD PTR _pfound$7[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN48@getopt_int

; 493  : 		    optarg = nameend + 1;

	mov	eax, DWORD PTR _nameend$9[ebp]
	add	eax, 1
	mov	DWORD PTR _optarg, eax
	jmp	$LN49@getopt_int
$LN48@getopt_int:

; 494  : 		else
; 495  : 		{
; 496  : 		    if (print_errors)

	cmp	DWORD PTR _print_errors$[ebp], 0
	je	$LN50@getopt_int

; 497  : 		    {
; 498  : 
; 499  : 			if (argv[optind - 1][1] == '-')

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4-4]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN51@getopt_int

; 500  : 			{
; 501  : 			    /* --option */
; 502  : 			    fprintf (stderr, _("\

	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	OFFSET ??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 503  : 					%s: option `--%s' doesn't allow an argument\n"),
; 504  : 				    argv[0], pfound->name);
; 505  : 			}

	jmp	SHORT $LN50@getopt_int
$LN51@getopt_int:

; 506  : 			else
; 507  : 			{
; 508  : 			    /* +option or -option */
; 509  : 			    fprintf (stderr, _("\

	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4-4]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H
$LN50@getopt_int:

; 510  : 					%s: option `%c%s' doesn't allow an argument\n"),
; 511  : 				    argv[0], argv[optind - 1][0], pfound->name);
; 512  : 			}
; 513  : 
; 514  : 		    }
; 515  : 
; 516  : 		    nextchar += strlen (nextchar);

	mov	eax, DWORD PTR _nextchar
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _nextchar
	mov	DWORD PTR _nextchar, eax

; 517  : 
; 518  : 		    optopt = pfound->val;

	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _optopt, ecx

; 519  : 		    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN49@getopt_int:

; 520  : 		}
; 521  : 	    }

	jmp	$LN47@getopt_int
$LN46@getopt_int:

; 522  : 	    else if (pfound->has_arg == 1)

	mov	eax, DWORD PTR _pfound$7[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN47@getopt_int

; 523  : 	    {
; 524  : 		if (optind < argc)

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _argc$[ebp]
	jge	SHORT $LN54@getopt_int

; 525  : 		    optarg = argv[optind++];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _optarg, edx
	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
	jmp	$LN47@getopt_int
$LN54@getopt_int:

; 526  : 		else
; 527  : 		{
; 528  : 		    if (print_errors)

	cmp	DWORD PTR _print_errors$[ebp], 0
	je	SHORT $LN56@getopt_int

; 529  : 		    {
; 530  : 			fprintf (stderr,

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN56@getopt_int:

; 531  : 				_("%s: option `%s' requires an argument\n"),
; 532  : 				argv[0], argv[optind - 1]);
; 533  : 		    }
; 534  : 		    nextchar += strlen (nextchar);

	mov	eax, DWORD PTR _nextchar
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _nextchar
	mov	DWORD PTR _nextchar, eax

; 535  : 		    optopt = pfound->val;

	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _optopt, ecx

; 536  : 		    return optstring[0] == ':' ? ':' : '?';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optstring$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN83@getopt_int
	mov	DWORD PTR tv316[ebp], 58		; 0000003aH
	jmp	SHORT $LN84@getopt_int
$LN83@getopt_int:
	mov	DWORD PTR tv316[ebp], 63		; 0000003fH
$LN84@getopt_int:
	mov	eax, DWORD PTR tv316[ebp]
	jmp	$LN1@getopt_int
$LN47@getopt_int:

; 537  : 		}
; 538  : 	    }
; 539  : 	    nextchar += strlen (nextchar);

	mov	eax, DWORD PTR _nextchar
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _nextchar
	mov	DWORD PTR _nextchar, eax

; 540  : 	    if (intind != NULL)

	cmp	DWORD PTR _intind$[ebp], 0
	je	SHORT $LN57@getopt_int

; 541  : 		*intind = option_index;

	mov	eax, DWORD PTR _intind$[ebp]
	mov	ecx, DWORD PTR _option_index$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN57@getopt_int:

; 542  : 	    if (pfound->flag)

	mov	eax, DWORD PTR _pfound$7[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN58@getopt_int

; 543  : 	    {
; 544  : 		*(pfound->flag) = pfound->val;

	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pfound$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx], eax

; 545  : 		return 0;

	xor	eax, eax
	jmp	$LN1@getopt_int
$LN58@getopt_int:

; 546  : 	    }
; 547  : 	    return pfound->val;

	mov	eax, DWORD PTR _pfound$7[ebp]
	mov	eax, DWORD PTR [eax+12]
	jmp	$LN1@getopt_int
$LN45@getopt_int:

; 548  : 	}
; 549  : 
; 550  : 	/* Can't find it as a int option.  If this is not getopt_int_only,
; 551  : 	   or the option starts with '--' or is not a valid short
; 552  : 	   option, then it's an error.
; 553  : 	   Otherwise interpret it as a short option.  */
; 554  : 	if (!int_only || argv[optind][1] == '-'
; 555  : 		|| my_index (optstring, *nextchar) == NULL)

	cmp	DWORD PTR _int_only$[ebp], 0
	je	SHORT $LN60@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN60@getopt_int
	mov	eax, DWORD PTR _nextchar
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _optstring$[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	$LN33@getopt_int
$LN60@getopt_int:

; 556  : 	{
; 557  : 	    if (print_errors)

	cmp	DWORD PTR _print_errors$[ebp], 0
	je	$LN61@getopt_int

; 558  : 	    {
; 559  : 
; 560  : 		if (argv[optind][1] == '-')

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN62@getopt_int

; 561  : 		{
; 562  : 		    /* --option */
; 563  : 		    fprintf (stderr, _("%s: unrecognized option `--%s'\n"),

	mov	eax, DWORD PTR _nextchar
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	OFFSET ??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 564  : 			    argv[0], nextchar);
; 565  : 		}

	jmp	SHORT $LN61@getopt_int
$LN62@getopt_int:

; 566  : 		else
; 567  : 		{
; 568  : 		    /* +option or -option */
; 569  : 		    fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),

	mov	eax, DWORD PTR _nextchar
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	movsx	ecx, BYTE PTR [eax+edx]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	OFFSET ??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H
$LN61@getopt_int:

; 570  : 			    argv[0], argv[optind][0], nextchar);
; 571  : 		}
; 572  : 
; 573  : 	    }
; 574  : 	    nextchar = (char *) "";

	mov	DWORD PTR _nextchar, OFFSET ??_C@_00CNPNBAHC@@

; 575  : 	    optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 576  : 	    optopt = 0;

	mov	DWORD PTR _optopt, 0

; 577  : 	    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN33@getopt_int:

; 578  : 	}
; 579  :     }
; 580  : 
; 581  :     /* Look at and handle the next short option-character.  */
; 582  : 
; 583  :     {
; 584  : 	char c = *nextchar++;

	mov	eax, DWORD PTR _nextchar
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$2[ebp], cl
	mov	edx, DWORD PTR _nextchar
	add	edx, 1
	mov	DWORD PTR _nextchar, edx

; 585  : 	char *temp = my_index (optstring, c);

	movsx	eax, BYTE PTR _c$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _optstring$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _temp$1[ebp], eax

; 586  : 
; 587  : 	/* Increment `optind' when we start to process its last character.  */
; 588  : 	if (*nextchar == '\0')

	mov	eax, DWORD PTR _nextchar
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN64@getopt_int

; 589  : 	    ++optind;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
$LN64@getopt_int:

; 590  : 
; 591  : 	if (temp == NULL || c == ':')

	cmp	DWORD PTR _temp$1[ebp], 0
	je	SHORT $LN66@getopt_int
	movsx	eax, BYTE PTR _c$2[ebp]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN65@getopt_int
$LN66@getopt_int:

; 592  : 	{
; 593  : 	    if (print_errors)

	cmp	DWORD PTR _print_errors$[ebp], 0
	je	SHORT $LN67@getopt_int

; 594  : 	    {
; 595  : 		    /* 1003.2 specifies the format of this message.  */
; 596  : 		    fprintf (stderr, _("%s: illegal option -- %c\n"), argv[0], c);

	movsx	eax, BYTE PTR _c$2[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	OFFSET ??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN67@getopt_int:

; 597  : 	    }
; 598  : 	    optopt = c;

	movsx	eax, BYTE PTR _c$2[ebp]
	mov	DWORD PTR _optopt, eax

; 599  : 	    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN65@getopt_int:

; 600  : 	}
; 601  : #ifdef SPECIAL_TREATMENT_FOR_W
; 602  : 	/* Convenience. Treat POSIX -W foo same as int option --foo */
; 603  : 	if (temp[0] == 'W' && temp[1] == ';')
; 604  : 	{
; 605  : 	    char *nameend;
; 606  : 	    const struct option *p;
; 607  : 	    const struct option *pfound = NULL;
; 608  : 	    int exact = 0;
; 609  : 	    int ambig = 0;
; 610  : 	    int indfound = 0;
; 611  : 	    int option_index;
; 612  : 
; 613  : 	    /* This is an option that requires an argument.  */
; 614  : 	    if (*nextchar != '\0')
; 615  : 	    {
; 616  : 		optarg = nextchar;
; 617  : 		/* If we end this ARGV-element by taking the rest as an arg,
; 618  : 		   we must advance to the next element now.  */
; 619  : 		optind++;
; 620  : 	    }
; 621  : 	    else if (optind == argc)
; 622  : 	    {
; 623  : 		if (print_errors)
; 624  : 		{
; 625  : 		    /* 1003.2 specifies the format of this message.  */
; 626  : 		    fprintf (stderr, _("%s: option requires an argument -- %c\n"),
; 627  : 			    argv[0], c);
; 628  : 		}
; 629  : 		optopt = c;
; 630  : 		if (optstring[0] == ':')
; 631  : 		    c = ':';
; 632  : 		else
; 633  : 		    c = '?';
; 634  : 		return c;
; 635  : 	    }
; 636  : 	    else
; 637  : 		/* We already incremented `optind' once;
; 638  : 		   increment it again when taking next ARGV-elt as argument.  */
; 639  : 		optarg = argv[optind++];
; 640  : 
; 641  : 	    /* optarg is now the argument, see if it's in the
; 642  : 	       table of intopts.  */
; 643  : 
; 644  : 	    for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
; 645  : 		/* Do nothing.  */ ;
; 646  : 
; 647  : 	    /* Test all int options for either exact match
; 648  : 	       or abbreviated matches.  */
; 649  : 	    for (p = intopts, option_index = 0; p->name; p++, option_index++)
; 650  : 		if (!strncmp (p->name, nextchar, nameend - nextchar))
; 651  : 		{
; 652  : 		    if ((unsigned int) (nameend - nextchar) == strlen (p->name))
; 653  : 		    {
; 654  : 			/* Exact match found.  */
; 655  : 			pfound = p;
; 656  : 			indfound = option_index;
; 657  : 			exact = 1;
; 658  : 			break;
; 659  : 		    }
; 660  : 		    else if (pfound == NULL)
; 661  : 		    {
; 662  : 			/* First nonexact match found.  */
; 663  : 			pfound = p;
; 664  : 			indfound = option_index;
; 665  : 		    }
; 666  : 		    else
; 667  : 			/* Second or later nonexact match found.  */
; 668  : 			ambig = 1;
; 669  : 		}
; 670  : 	    if (ambig && !exact)
; 671  : 	    {
; 672  : 		if (print_errors)
; 673  : 		{
; 674  : 		    fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
; 675  : 			    argv[0], argv[optind]);
; 676  : 		}
; 677  : 		nextchar += strlen (nextchar);
; 678  : 		optind++;
; 679  : 		return '?';
; 680  : 	    }
; 681  : 	    if (pfound != NULL)
; 682  : 	    {
; 683  : 		option_index = indfound;
; 684  : 		if (*nameend)
; 685  : 		{
; 686  : 		    /* Don't test has_arg with >, because some C compilers don't
; 687  : 		       allow it to be used on enums.  */
; 688  : 		    if (pfound->has_arg)
; 689  : 			optarg = nameend + 1;
; 690  : 		    else
; 691  : 		    {
; 692  : 			if (print_errors)
; 693  : 			{
; 694  : 			    fprintf (stderr, _("\
; 695  : 					%s: option `-W %s' doesn't allow an argument\n"),
; 696  : 				    argv[0], pfound->name);
; 697  : 			}
; 698  : 
; 699  : 			nextchar += strlen (nextchar);
; 700  : 			return '?';
; 701  : 		    }
; 702  : 		}
; 703  : 		else if (pfound->has_arg == 1)
; 704  : 		{
; 705  : 		    if (optind < argc)
; 706  : 			optarg = argv[optind++];
; 707  : 		    else
; 708  : 		    {
; 709  : 			if (print_errors)
; 710  : 			{
; 711  : 			    fprintf (stderr,
; 712  : 				    _("%s: option `%s' requires an argument\n"),
; 713  : 				    argv[0], argv[optind - 1]);
; 714  : 			}
; 715  : 			nextchar += strlen (nextchar);
; 716  : 			return optstring[0] == ':' ? ':' : '?';
; 717  : 		    }
; 718  : 		}
; 719  : 		nextchar += strlen (nextchar);
; 720  : 		if (intind != NULL)
; 721  : 		    *intind = option_index;
; 722  : 		if (pfound->flag)
; 723  : 		{
; 724  : 		    *(pfound->flag) = pfound->val;
; 725  : 		    return 0;
; 726  : 		}
; 727  : 		return pfound->val;
; 728  : 	    }
; 729  : 	    nextchar = NULL;
; 730  : 	    return 'W';	/* Let the application handle it.   */
; 731  : 	}
; 732  : #endif
; 733  : 	if (temp[1] == ':')

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _temp$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	jne	$LN68@getopt_int

; 734  : 	{
; 735  : 	    if (temp[2] == ':')

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _temp$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN69@getopt_int

; 736  : 	    {
; 737  : 		/* This is an option that accepts an argument optionally.  */
; 738  : 		if (*nextchar != '\0')

	mov	eax, DWORD PTR _nextchar
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN71@getopt_int

; 739  : 		{
; 740  : 		    optarg = nextchar;

	mov	eax, DWORD PTR _nextchar
	mov	DWORD PTR _optarg, eax

; 741  : 		    optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 742  : 		}

	jmp	SHORT $LN72@getopt_int
$LN71@getopt_int:

; 743  : 		else
; 744  : 		    optarg = NULL;

	mov	DWORD PTR _optarg, 0
$LN72@getopt_int:

; 745  : 		nextchar = NULL;

	mov	DWORD PTR _nextchar, 0

; 746  : 	    }

	jmp	$LN68@getopt_int
$LN69@getopt_int:

; 747  : 	    else
; 748  : 	    {
; 749  : 		/* This is an option that requires an argument.  */
; 750  : 		if (*nextchar != '\0')

	mov	eax, DWORD PTR _nextchar
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN73@getopt_int

; 751  : 		{
; 752  : 		    optarg = nextchar;

	mov	eax, DWORD PTR _nextchar
	mov	DWORD PTR _optarg, eax

; 753  : 		    /* If we end this ARGV-element by taking the rest as an arg,
; 754  : 		       we must advance to the next element now.  */
; 755  : 		    optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 756  : 		}

	jmp	$LN74@getopt_int
$LN73@getopt_int:

; 757  : 		else if (optind == argc)

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _argc$[ebp]
	jne	SHORT $LN75@getopt_int

; 758  : 		{
; 759  : 		    if (print_errors)

	cmp	DWORD PTR _print_errors$[ebp], 0
	je	SHORT $LN77@getopt_int

; 760  : 		    {
; 761  : 			/* 1003.2 specifies the format of this message.  */
; 762  : 			fprintf (stderr,

	movsx	eax, BYTE PTR _c$2[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	OFFSET ??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN77@getopt_int:

; 763  : 				_("%s: option requires an argument -- %c\n"),
; 764  : 				argv[0], c);
; 765  : 		    }
; 766  : 		    optopt = c;

	movsx	eax, BYTE PTR _c$2[ebp]
	mov	DWORD PTR _optopt, eax

; 767  : 		    if (optstring[0] == ':')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optstring$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN78@getopt_int

; 768  : 			c = ':';

	mov	BYTE PTR _c$2[ebp], 58			; 0000003aH
	jmp	SHORT $LN79@getopt_int
$LN78@getopt_int:

; 769  : 		    else
; 770  : 			c = '?';

	mov	BYTE PTR _c$2[ebp], 63			; 0000003fH
$LN79@getopt_int:

; 771  : 		}

	jmp	SHORT $LN74@getopt_int
$LN75@getopt_int:

; 772  : 		else
; 773  : 		    /* We already incremented `optind' once;
; 774  : 		       increment it again when taking next ARGV-elt as argument.  */
; 775  : 		    optarg = argv[optind++];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _optarg, edx
	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
$LN74@getopt_int:

; 776  : 		nextchar = NULL;

	mov	DWORD PTR _nextchar, 0
$LN68@getopt_int:

; 777  : 	    }
; 778  : 	}
; 779  : 	return c;

	movsx	eax, BYTE PTR _c$2[ebp]
$LN1@getopt_int:

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__getopt_internal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\getopt.c
;	COMDAT _getopt_int_only
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_options$ = 16						; size = 4
_int_options$ = 20					; size = 4
_opt_index$ = 24					; size = 4
_getopt_int_only PROC					; COMDAT

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8D133928_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 803  :     return _getopt_internal (argc, argv, options, int_options, opt_index, 1);

	push	1
	mov	eax, DWORD PTR _opt_index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ecx
	call	__getopt_internal
	add	esp, 24					; 00000018H

; 804  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getopt_int_only ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\getopt.c
;	COMDAT _getopt_int
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_options$ = 16						; size = 4
_int_options$ = 20					; size = 4
_opt_index$ = 24					; size = 4
_getopt_int PROC					; COMDAT

; 791  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8D133928_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 792  :     return _getopt_internal (argc, argv, options, int_options, opt_index, 0);

	push	0
	mov	eax, DWORD PTR _opt_index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ecx
	call	__getopt_internal
	add	esp, 24					; 00000018H

; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getopt_int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 844  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 646  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A2143F22_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
