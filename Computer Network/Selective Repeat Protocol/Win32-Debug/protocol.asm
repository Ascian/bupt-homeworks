; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

	TITLE	D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\Win32-Debug\protocol.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_06HMNHKJD@utopia@				; `string'
PUBLIC	??_C@_05ONANONLM@flood@				; `string'
PUBLIC	??_C@_04CMBNNLNM@ibib@				; `string'
PUBLIC	??_C@_05HPGGOJCM@nolog@				; `string'
PUBLIC	??_C@_05GFCDIDHO@debug@				; `string'
PUBLIC	??_C@_04LPGMAPLE@port@				; `string'
PUBLIC	??_C@_03BMIBANNE@ber@				; `string'
PUBLIC	??_C@_03MGHMBJCF@log@				; `string'
PUBLIC	??_C@_03KAFGPDAP@ttl@				; `string'
msvcjmc	SEGMENT
__32FB09EA_concurrencysal@h DB 01H
__92642135_sal@h DB 01H
__91763366_vadefs@h DB 01H
__53563FEE_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__A0B61CF9_time@h DB 01H
__D0DFFAC6_winpackagefamily@h DB 01H
__D0D0F397_winapifamily@h DB 01H
__94A3FDDD_sdkddkver@h DB 01H
__3A5FEF39_excpt@h DB 01H
__DDA4E3CF_stdarg@h DB 01H
__1C9F390F_specstrings_undef@h DB 01H
__36A21E95_specstrings_strict@h DB 01H
__452FE810_sdv_driverspecs@h DB 01H
__30F344B3_driverspecs@h DB 01H
__BD886E18_specstrings@h DB 01H
__5DB64B66_corecrt_wctype@h DB 01H
__B2D2BA86_ctype@h DB 01H
__BF9C347F_kernelspecs@h DB 01H
__79C7FC57_basetsd@h DB 01H
__CDDAF8CA_errno@h DB 01H
__1AB1F8E3_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__DF4F952E_pshpack4@h DB 01H
__7FCD0577_poppack@h DB 01H
__DBC2E99C_pshpack2@h DB 01H
__D6556C4A_pshpack8@h DB 01H
__D98457C5_pshpack1@h DB 01H
__614C4572_apiset@h DB 01H
__8500295D_ktmtypes@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__156BD51A_minwindef@h DB 01H
__F9B9A8F7_windef@h DB 01H
__BD2C4590_apisetcconv@h DB 01H
__18251742_minwinbase@h DB 01H
__23611203_apiquery2@h DB 01H
__C914CD48_processenv@h DB 01H
__996311FD_fileapi@h DB 01H
__41AEF397_fileapifromapp@h DB 01H
__65579FF3_debugapi@h DB 01H
__476FCB5A_utilapiset@h DB 01H
__089D2E42_handleapi@h DB 01H
__B16F04F5_errhandlingapi@h DB 01H
__81CCB02F_fibersapi@h DB 01H
__A9B4C5F0_namedpipeapi@h DB 01H
__C209F2C8_profileapi@h DB 01H
__34C22DC8_heapapi@h DB 01H
__8A238485_ioapiset@h DB 01H
__4826BA69_synchapi@h DB 01H
__6A31599C_interlockedapi@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__7BB37CFA_sysinfoapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__6D078C0D_enclaveapi@h DB 01H
__3663CE50_threadpoollegacyapiset@h DB 01H
__E16717D9_threadpoolapiset@h DB 01H
__4A6035CC_jobapi@h DB 01H
__62EEB553_jobapi2@h DB 01H
__9F22E7EF_wow64apiset@h DB 01H
__E86B4A9A_libloaderapi@h DB 01H
__EB536E54_securitybaseapi@h DB 01H
__E915C287_namespaceapi@h DB 01H
__C66F44F2_systemtopologyapi@h DB 01H
__B6175B28_processtopologyapi@h DB 01H
__9E4AD838_securityappcontainer@h DB 01H
__F599FDAE_realtimeapiset@h DB 01H
__D4435474_winerror@h DB 01H
__F94F31E6_timezoneapi@h DB 01H
__B3ED30D4_winbase@h DB 01H
__E9F7D11F_wingdi@h DB 01H
__AC21C382_tvout@h DB 01H
__DB057BA3_winuser@h DB 01H
__A1BAD304_datetimeapi@h DB 01H
__30E2BD27_winnls@h DB 01H
__B7FF4B97_stringapiset@h DB 01H
__66C87297_wincontypes@h DB 01H
__1317218F_consoleapi@h DB 01H
__8D62D26D_consoleapi2@h DB 01H
__8CA0B85A_consoleapi3@h DB 01H
__CE39E65B_wincon@h DB 01H
__F6801ACC_verrsrc@h DB 01H
__1CB844D9_winver@h DB 01H
__D0CFA71C_reason@h DB 01H
__F3D58382_winreg@h DB 01H
__34C28572_wnnc@h DB 01H
__0617DE59_winnetwk@h DB 01H
__93AC9EF8_cderr@h DB 01H
__3AE29FFA_dde@h DB 01H
__48250249_ddeml@h DB 01H
__4605C6DD_dlgs@h DB 01H
__C826BBA2_lzexpand@h DB 01H
__B8DFB118_mmsyscom@h DB 01H
__EDC2A662_mciapi@h DB 01H
__87B17D5B_mmiscapi@h DB 01H
__0C4862FC_mmiscapi2@h DB 01H
__83F5D08C_playsoundapi@h DB 01H
__CA3F1D44_mmeapi@h DB 01H
__BD2270BE_timeapi@h DB 01H
__397CAA2F_joystickapi@h DB 01H
__05A21AEE_mmsystem@h DB 01H
__6E1DF0B6_nb30@h DB 01H
__75098885_rpcdcep@h DB 01H
__D8AC8DD5_rpcdce@h DB 01H
__2F1118EF_rpcnsi@h DB 01H
__0DE10DFC_rpcnterr@h DB 01H
__4497164E_rpcasync@h DB 01H
__06CA6763_rpc@h DB 01H
__C32EC2F2_shellapi@h DB 01H
__B289ECB8_winperf@h DB 01H
__FD938996_bcrypt@h DB 01H
__4E32BFB9_ncrypt@h DB 01H
__815AA9AD_dpapi@h DB 01H
__0B2E95FF_wincrypt@h DB 01H
__288F6C52_winefs@h DB 01H
__B3F2ECA2_rpcnsip@h DB 01H
__AFB43543_rpcsal@h DB 01H
__16A21838_rpcndr@h DB 01H
__5314805F_wtypesbase@h DB 01H
__6EEE3703_wtypes@h DB 01H
__A7113148_winioctl@h DB 01H
__C595A37C_winsmcrd@h DB 01H
__42C56FB7_winscard@h DB 01H
__C4703BCA_prsht@h DB 01H
__D4D77F19_winspool@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__570D733F_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__B47185B4_unknwnbase@h DB 01H
__B64C33F8_objidlbase@h DB 01H
__EA871F04_cguid@h DB 01H
__C78732AB_combaseapi@h DB 01H
__744BF5DA_unknwn@h DB 01H
__66C491E7_objidl@h DB 01H
__A217658B_oaidl@h DB 01H
__8485F416_propidlbase@h DB 01H
__65805CE1_coml2api@h DB 01H
__C7AD586F_oleidl@h DB 01H
__CBE55221_servprov@h DB 01H
__5B1E268A_msxml@h DB 01H
__1B3D3678_urlmon@h DB 01H
__EC5BC72C_propidl@h DB 01H
__0DD0E8F8_objbase@h DB 01H
__6DA674A0_oleauto@h DB 01H
__F7931962_ole2@h DB 01H
__870E9EB1_commdlg@h DB 01H
__A118E6DC_stralign@h DB 01H
__8B10FA9F_winsvc@h DB 01H
__BEDBF511_mcx@h DB 01H
__D3BCC989_ime_cmodes@h DB 01H
__B1694579_imm@h DB 01H
__4D4D253D_windows@h DB 01H
__07EA6B7C_inaddr@h DB 01H
__9ED0251E_winsock@h DB 01H
__A9063C41_corecrt_share@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__2671BD82_corecrt_io@h DB 01H
__9B190114_io@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__64F617E8_types@h DB 01H
__E2B48F07_timeb@h DB 01H
__1AC1E0A0_getopt@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__9158E1CF_lprintf@h DB 01H
__0B59982E_protocol@h DB 01H
__9C8B41A6_protocol@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_03KAFGPDAP@ttl@
CONST	SEGMENT
??_C@_03KAFGPDAP@ttl@ DB 'ttl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log@
CONST	SEGMENT
??_C@_03MGHMBJCF@log@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMIBANNE@ber@
CONST	SEGMENT
??_C@_03BMIBANNE@ber@ DB 'ber', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LPGMAPLE@port@
CONST	SEGMENT
??_C@_04LPGMAPLE@port@ DB 'port', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug@ DB 'debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPGGOJCM@nolog@
CONST	SEGMENT
??_C@_05HPGGOJCM@nolog@ DB 'nolog', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBNNLNM@ibib@
CONST	SEGMENT
??_C@_04CMBNNLNM@ibib@ DB 'ibib', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONANONLM@flood@
CONST	SEGMENT
??_C@_05ONANONLM@flood@ DB 'flood', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMNHKJD@utopia@
CONST	SEGMENT
??_C@_06HMNHKJD@utopia@ DB 'utopia', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_get_ms
PUBLIC	_protocol_init
PUBLIC	_wait_for_event
PUBLIC	_enable_network_layer
PUBLIC	_disable_network_layer
PUBLIC	_get_packet
PUBLIC	_put_packet
PUBLIC	_recv_frame
PUBLIC	_send_frame
PUBLIC	_phl_sq_len
PUBLIC	_start_timer
PUBLIC	_stop_timer
PUBLIC	_start_ack_timer
PUBLIC	_stop_ack_timer
PUBLIC	_station_name
PUBLIC	_dbg_event
PUBLIC	_dbg_frame
PUBLIC	_dbg_warning
PUBLIC	_get_timer
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@ ; `string'
PUBLIC	??_C@_01FHEEJDEE@A@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B@				; `string'
PUBLIC	??_C@_03MAMPKPPK@XXX@				; `string'
PUBLIC	??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@ ; `string'
PUBLIC	??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@	; `string'
PUBLIC	??_C@_03JODACOMD@nul@				; `string'
PUBLIC	??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@		; `string'
PUBLIC	??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@ ; `string'
PUBLIC	??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@ ; `string'
PUBLIC	??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@	; `string'
PUBLIC	??_C@_04JLMDILM@?4exe@				; `string'
PUBLIC	??_C@_06GOMLAJLH@?9A?4log@			; `string'
PUBLIC	??_C@_06OIFPHLBJ@?9B?4log@			; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@ ; `string'
PUBLIC	??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0M@LKGDGICL@May?520?52022@		; `string'
PUBLIC	??_C@_03EMGHBCAM@4?40@				; `string'
PUBLIC	??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@ ; `string'
PUBLIC	??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@ ; `string'
PUBLIC	??_C@_05KDIEGDNJ@?$CF?41E?6@			; `string'
PUBLIC	??_C@_02NODKCLPH@0?6@				; `string'
PUBLIC	??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@ ; `string'
PUBLIC	??_C@_0BC@BNICANMP@Create?5TCP?5socket@		; `string'
PUBLIC	??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@ ; `string'
PUBLIC	??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@ ; `string'
PUBLIC	??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@ ; `string'
PUBLIC	??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@ ; `string'
PUBLIC	??_C@_06MJLDIBBJ@Done?4?6@			; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41@			; `string'
PUBLIC	??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@ ; `string'
PUBLIC	??_C@_08OPNBKLNK@Failed?$CB?6@			; `string'
PUBLIC	??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@ ; `string'
PUBLIC	??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@		; `string'
PUBLIC	??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@ ; `string'
PUBLIC	??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@	; `string'
PUBLIC	??_C@_0BB@IAFLKGG@No?5enough?5memory@		; `string'
PUBLIC	??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@	; `string'
PUBLIC	??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@ ; `string'
PUBLIC	??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@ ; `string'
PUBLIC	??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@ ; `string'
PUBLIC	??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@ ; `string'
PUBLIC	??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@		; `string'
PUBLIC	??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@ ; `string'
PUBLIC	??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@ ; `string'
PUBLIC	??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@ ; `string'
PUBLIC	??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@ ; `string'
PUBLIC	??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@	; `string'
PUBLIC	??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@ ; `string'
PUBLIC	??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@ ; `string'
PUBLIC	??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@ ; `string'
PUBLIC	??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_06EJNPPGH@Quit?4?6@			; `string'
PUBLIC	??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@400c000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40bf400000000000
PUBLIC	__real@40e0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__asctime:PROC
EXTRN	__imp___localtime64:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__tolower:PROC
EXTRN	__imp___errno:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__strtod:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	_accept@12:PROC
EXTRN	_bind@12:PROC
EXTRN	_connect@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_listen@8:PROC
EXTRN	_recv@16:PROC
EXTRN	_select@20:PROC
EXTRN	_send@16:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_socket@12:PROC
EXTRN	_WSAStartup@8:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___ftime64:PROC
EXTRN	_getopt_int:PROC
EXTRN	_pow:PROC
EXTRN	_lprintf:PROC
EXTRN	___v_lprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	_optarg:DWORD
EXTRN	_optind:DWORD
EXTRN	_log_file:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_epoch	DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_head_magic DD	020H DUP (?)
_station DD	01H DUP (?)
_mode_ibib DD	01H DUP (?)
_mode_flood DD	01H DUP (?)
_debug_mask DD	01H DUP (?)
_sock	DD	01H DUP (?)
_now	DD	01H DUP (?)
_noise	DD	01H DUP (?)
_sq	DB	020000H DUP (?)
_sq_head DD	01H DUP (?)
_sq_tail DD	01H DUP (?)
_send_bytes_allowed DD 01H DUP (?)
?last_ts@?1??socket_send@@9@9 DD 01H DUP (?)		; `socket_send'::`2'::last_ts
_rblk_head DD	01H DUP (?)
_rblk_tail DD	01H DUP (?)
_nbits	DD	01H DUP (?)
_timer	DD	081H DUP (?)
_network_layer_active DD 01H DUP (?)
_rpackets DD	01H DUP (?)
_rbytes	DD	01H DUP (?)
?last_ts@?1??network_layer_ready@@9@9 DD 01H DUP (?)	; `network_layer_ready'::`2'::last_ts
_layer3_ready DD 01H DUP (?)
?pkt_no@?1??get_packet@@9@9 DD 01H DUP (?)		; `get_packet'::`2'::pkt_no
_ts0	DD	01H DUP (?)
?last_ts@?1??put_packet@@9@9 DD 01H DUP (?)		; `put_packet'::`2'::last_ts
_sleep_cnt DD	01H DUP (?)
_start_ms DD	01H DUP (?)
_wakeup_ms DD	01H DUP (?)
_busy_cnt DD	01H DUP (?)
_bias_cnt DD	01H DUP (?)
_rf_head DD	01H DUP (?)
_rf_tail DD	01H DUP (?)
_rf_buf	DD	01H DUP (?)
	ALIGN	8

?last_warn@?BF@??wait_for_event@@9@9 DQ 01H DUP (?)	; `wait_for_event'::`21'::last_warn
_foot_magic DD	020H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@40e0000000000000
CONST	SEGMENT
__real@40e0000000000000 DQ 040e0000000000000r	; 32768
CONST	ENDS
;	COMDAT __real@40bf400000000000
CONST	SEGMENT
__real@40bf400000000000 DQ 040bf400000000000r	; 8000
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@400c000000000000
CONST	SEGMENT
__real@400c000000000000 DQ 0400c000000000000r	; 3.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@
CONST	SEGMENT
??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@ DB 'Memory used'
	DB	' by ''protocol.lib'' is corrupted by your program', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EJNPPGH@Quit?4?6@
CONST	SEGMENT
??_C@_06EJNPPGH@Quit?4?6@ DB 'Quit.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@ DB '+'
	DB	'+++++ Sleep(%d)=%d+%d (cnt %d)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@
CONST	SEGMENT
??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@ DB '-'
	DB	'----- noSleep %d, sleep %d, Elapse %d ticks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@
CONST	SEGMENT
??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@ DB '='
	DB	'===== CPU BUSY for %d ms (cnt %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@
CONST	SEGMENT
??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@ DB '** W'
	DB	'ARNING: System too busy, sleep %d ms, but be awakened %d ms l'
	DB	'ater', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@
CONST	SEGMENT
??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@ DB 'system select()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@
CONST	SEGMENT
??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@ DB 'rec'
	DB	'v_frame(): %d-byte buffer is too small to save %d-byte receiv'
	DB	'ed frame', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@
CONST	SEGMENT
??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@ DB 'recv_fr'
	DB	'ame(): Receiving Queue is empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@
CONST	SEGMENT
??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@ DB '.'
	DB	'... %d packets received, %.0f bps, %.2f%%, Err %d (%.1e)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@
CONST	SEGMENT
??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@ DB 'Network Laye'
	DB	'r received a bad packet from data link layer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@
CONST	SEGMENT
??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@ DB 'Bad Packet length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@
CONST	SEGMENT
??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@ DB 'get_pa'
	DB	'cket(): Network layer is not ready for a new packet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@
CONST	SEGMENT
??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@ DB 'start'
	DB	'_timer(): timer No. must be 0~128', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@
CONST	SEGMENT
??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@ DB 'recv_by'
	DB	'te(): Receiving Queue is empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@
CONST	SEGMENT
??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@ DB 'Impose nois'
	DB	'e on received data, %u/%u=%.1E', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@
CONST	SEGMENT
??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@ DB 'TCP disconnected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IAFLKGG@No?5enough?5memory@
CONST	SEGMENT
??_C@_0BB@IAFLKGG@No?5enough?5memory@ DB 'No enough memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@
CONST	SEGMENT
??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@ DB 'TCP Disconnected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@
CONST	SEGMENT
??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@ DB 'Physical Laye'
	DB	'r Sending Queue overflow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================='
	DB	'===', 0aH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@
CONST	SEGMENT
??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@ DB 'New epoch: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@
CONST	SEGMENT
??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@ DB 'Station B fa'
	DB	'iled to connect station A', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OPNBKLNK@Failed?$CB?6@
CONST	SEGMENT
??_C@_08OPNBKLNK@Failed?$CB?6@ DB 'Failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@
CONST	SEGMENT
??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@ DB 'Station B is '
	DB	'connecting station A (TCP port %u) ... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJLDIBBJ@Done?4?6@
CONST	SEGMENT
??_C@_06MJLDIBBJ@Done?4?6@ DB 'Done.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@
CONST	SEGMENT
??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@ DB 'Station A fai'
	DB	'led to communicate with station B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@
CONST	SEGMENT
??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@ DB 'Station A is'
	DB	' waiting for station B on TCP port %u ... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@
CONST	SEGMENT
??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@ DB 'Station A f'
	DB	'ailed to bind TCP port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@
CONST	SEGMENT
??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@ DB 'Station A:'
	DB	' Failed to bind TCP port %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BNICANMP@Create?5TCP?5socket@
CONST	SEGMENT
??_C@_0BC@BNICANMP@Create?5TCP?5socket@ DB 'Create TCP socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@
CONST	SEGMENT
??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@ DB 'L'
	DB	'og file "%s", TCP port %d, debug mask 0x%02x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NODKCLPH@0?6@
CONST	SEGMENT
??_C@_02NODKCLPH@0?6@ DB '0', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIEGDNJ@?$CF?41E?6@
CONST	SEGMENT
??_C@_05KDIEGDNJ@?$CF?41E?6@ DB '%.1E', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@
CONST	SEGMENT
??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@ DB 'Chan'
	DB	'nel: %d bps, %d ms propagation delay, bit error rate ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@
CONST	SEGMENT
??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@ DB 'Protocol'
	DB	'.lib, version %s, jiangyanjun0718@bupt.edu.cn', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMGHBCAM@4?40@
CONST	SEGMENT
??_C@_03EMGHBCAM@4?40@ DB '4.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LKGDGICL@May?520?52022@
CONST	SEGMENT
??_C@_0M@LKGDGICL@May?520?52022@ DB 'May 20 2022', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================', 0aH
	DB	'                    Station %s                               '
	DB	0aH, '--------------------------------------------------------'
	DB	'-----', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@
CONST	SEGMENT
??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@ DB 'WARNING: Fa'
	DB	'iled to create log file "%s": %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIFPHLBJ@?9B?4log@
CONST	SEGMENT
??_C@_06OIFPHLBJ@?9B?4log@ DB '-B.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GOMLAJLH@?9A?4log@
CONST	SEGMENT
??_C@_06GOMLAJLH@?9A?4log@ DB '-A.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLMDILM@?4exe@
CONST	SEGMENT
??_C@_04JLMDILM@?4exe@ DB '.exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
CONST	SEGMENT
??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@ DB 0aH, 'FATAL: %s', 0aH, 'A'
	DB	'bort.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@
CONST	SEGMENT
??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@ DB 'Station'
	DB	' name must be ''A'' or ''B''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@
CONST	SEGMENT
??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@ DB 'ERROR: Unsupported'
	DB	' option', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@
CONST	SEGMENT
??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@ DB 'Bad BER %.3f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JODACOMD@nul@
CONST	SEGMENT
??_C@_03JODACOMD@nul@ DB 'nul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@
CONST	SEGMENT
??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@ DB '?ufind:p:b:l:t:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@
CONST	SEGMENT
??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@ DB 0aH
	DB	'Options : ', 0aH, '    -?, --help : print this', 0aH, '    -u'
	DB	', --utopia : utopia channel (an error-free channel)', 0aH, ' '
	DB	'   -f, --flood : flood traffic', 0aH, '    -i, --ibib  : set '
	DB	'station B layer 3 sender mode as IDLE-BUSY-IDLE-BUSY-...', 0aH
	DB	'    -n, --nolog : do not create log file', 0aH, '    -d, --de'
	DB	'bug=<0-7>: debug mask (bit0:event, bit1:frame, bit2:warning)', 0aH
	DB	'    -p, --port=<port#> : TCP port number (default: %u)', 0aH, ' '
	DB	'   -b, --ber=<ber> : Bit Error Rate (received data only)', 0aH
	DB	'    -l, --log=<filename> : using assigned file as log file', 0aH
	DB	'    -t, --ttl=<seconds> : set time-to-live', 0aH, 0aH, 'i.e.', 0aH
	DB	'    %s -fd3 -b 1e-4 A', 0aH, '    %s --flood --debug=3 --ber='
	DB	'1e-4 A', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@
CONST	SEGMENT
??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@ DB 0aH
	DB	'Usage:', 0aH, '  %s <options> <station-name>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAMPKPPK@XXX@
CONST	SEGMENT
??_C@_03MAMPKPPK@XXX@ DB 'XXX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B@
CONST	SEGMENT
??_C@_01HMGJMAIH@B@ DB 'B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01FHEEJDEE@A@
CONST	SEGMENT
??_C@_01FHEEJDEE@A@ DB 'A', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_ber	DQ	03ee4f8b588e368f1r		; 1e-05
_mode_cycle DD	064H
_mode_life DD	07fffff00H
_mode_tick DD	0fH
_mode_seed DD	098bcde1H
_port	DW	0e708H
	ORG $+6
_intopts DD	FLAT:??_C@_04PCJFHION@help@
	DD	00H
	DD	00H
	DD	03fH
	DD	FLAT:??_C@_06HMNHKJD@utopia@
	DD	00H
	DD	00H
	DD	075H
	DD	FLAT:??_C@_05ONANONLM@flood@
	DD	00H
	DD	00H
	DD	066H
	DD	FLAT:??_C@_04CMBNNLNM@ibib@
	DD	00H
	DD	00H
	DD	069H
	DD	FLAT:??_C@_05HPGGOJCM@nolog@
	DD	00H
	DD	00H
	DD	06eH
	DD	FLAT:??_C@_05GFCDIDHO@debug@
	DD	01H
	DD	00H
	DD	064H
	DD	FLAT:??_C@_04LPGMAPLE@port@
	DD	01H
	DD	00H
	DD	070H
	DD	FLAT:??_C@_03BMIBANNE@ber@
	DD	01H
	DD	00H
	DD	062H
	DD	FLAT:??_C@_03MGHMBJCF@log@
	DD	01H
	DD	00H
	DD	06cH
	DD	FLAT:??_C@_03KAFGPDAP@ttl@
	DD	01H
	DD	00H
	DD	074H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_inform_phl_ready DD 01H
?holdrand@?1??randA@@9@9 DD 065109bc4H			; `randA'::`2'::holdrand
?holdrand@?1??randB@@9@9 DD 01e459090H			; `randB'::`2'::holdrand
_DATA	ENDS
;	COMDAT ??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@
CONST	SEGMENT
??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@ DB 'Windows Socket DLL '
	DB	'Error', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	04deH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0128H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0628H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	0441H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	0b2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	025H
	DB	08dH
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _randB
_TEXT	SEGMENT
_randB	PROC						; COMDAT

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 628  :     static unsigned int holdrand = 0x1e459090;
; 629  :     return ((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff;

	imul	eax, DWORD PTR ?holdrand@?1??randB@@9@9, 214013
	add	eax, 2531011				; 00269ec3H
	mov	DWORD PTR ?holdrand@?1??randB@@9@9, eax
	mov	eax, DWORD PTR ?holdrand@?1??randB@@9@9
	shr	eax, 16					; 00000010H
	and	eax, 32767				; 00007fffH

; 630  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_randB	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _randA
_TEXT	SEGMENT
_randA	PROC						; COMDAT

; 621  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 622  :     static unsigned int holdrand = 0x65109bc4;
; 623  :     return ((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff;

	imul	eax, DWORD PTR ?holdrand@?1??randA@@9@9, 214013
	add	eax, 2531011				; 00269ec3H
	mov	DWORD PTR ?holdrand@?1??randA@@9@9, eax
	mov	eax, DWORD PTR ?holdrand@?1??randA@@9@9
	shr	eax, 16					; 00000010H
	and	eax, 32767				; 00007fffH

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_randA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _network_layer_ready
_TEXT	SEGMENT
_network_layer_ready PROC				; COMDAT

; 594  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 595  :     static int last_ts = 0;
; 596  : 
; 597  :     if (!network_layer_active)

	cmp	DWORD PTR _network_layer_active, 0
	jne	SHORT $LN2@network_la

; 598  :         return 0;

	xor	eax, eax
	jmp	$LN1@network_la
$LN2@network_la:

; 599  : 
; 600  :     if (mode_flood) 

	cmp	DWORD PTR _mode_flood, 0
	je	SHORT $LN3@network_la

; 601  :         return 1;

	mov	eax, 1
	jmp	$LN1@network_la
$LN3@network_la:

; 602  : 
; 603  :     if ((now - last_ts) * CHAN_BPS / 8 / 1000 < PKT_LEN * 3 / 4)

	mov	eax, DWORD PTR _now
	sub	eax, DWORD PTR ?last_ts@?1??network_layer_ready@@9@9
	imul	eax, eax, 8000
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, 192				; 000000c0H
	jge	SHORT $LN4@network_la

; 604  :         return 0;

	xor	eax, eax
	jmp	$LN1@network_la
$LN4@network_la:

; 605  : 
; 606  :     if (station == 'b') {

	cmp	DWORD PTR _station, 98			; 00000062H
	jne	SHORT $LN5@network_la

; 607  :         if (now / 1000 / mode_cycle % 2 != mode_ibib) {

	mov	eax, DWORD PTR _now
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cdq
	idiv	DWORD PTR _mode_cycle
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN10@network_la
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN10@network_la:
	cmp	eax, DWORD PTR _mode_ibib
	je	SHORT $LN6@network_la

; 608  :             if (now - last_ts < 4000 + rand() % 500)

	mov	esi, DWORD PTR _now
	sub	esi, DWORD PTR ?last_ts@?1??network_layer_ready@@9@9
	mov	edi, esp
	call	DWORD PTR __imp__rand
	cmp	edi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	add	edx, 4000				; 00000fa0H
	cmp	esi, edx
	jge	SHORT $LN6@network_la

; 609  :                 return 0;

	xor	eax, eax
	jmp	SHORT $LN1@network_la
$LN6@network_la:

; 610  :         }
; 611  :         if (now < CHAN_DELAY + 3 * PKT_LEN * 8000 / CHAN_BPS)

	cmp	DWORD PTR _now, 1038			; 0000040eH
	jge	SHORT $LN5@network_la

; 612  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@network_la
$LN5@network_la:

; 613  :     }
; 614  : 
; 615  :     last_ts = now;

	mov	eax, DWORD PTR _now
	mov	DWORD PTR ?last_ts@?1??network_layer_ready@@9@9, eax

; 616  : 
; 617  :     return 1;

	mov	eax, 1
$LN1@network_la:

; 618  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_network_layer_ready ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _scan_timer
_TEXT	SEGMENT
tv75 = -208						; size = 4
_i$ = -8						; size = 4
_nr$ = 8						; size = 4
_scan_timer PROC					; COMDAT

; 565  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 566  :     int i;
; 567  : 
; 568  :     for (i = 0; i < NTIMER; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@scan_timer
$LN2@scan_timer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@scan_timer:
	cmp	DWORD PTR _i$[ebp], 129			; 00000081H
	jge	SHORT $LN3@scan_timer

; 569  :         if (timer[i] && timer[i] <= now) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _timer[eax*4], 0
	je	SHORT $LN5@scan_timer
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _timer[eax*4]
	cmp	ecx, DWORD PTR _now
	jg	SHORT $LN5@scan_timer

; 570  :             *nr = i;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 571  :             timer[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _timer[eax*4], 0

; 572  :             return i == ACK_TIMER_ID ? ACK_TIMEOUT : DATA_TIMEOUT;

	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jne	SHORT $LN7@scan_timer
	mov	DWORD PTR tv75[ebp], 4
	jmp	SHORT $LN8@scan_timer
$LN7@scan_timer:
	mov	DWORD PTR tv75[ebp], 3
$LN8@scan_timer:
	mov	eax, DWORD PTR tv75[ebp]
	jmp	SHORT $LN1@scan_timer
$LN5@scan_timer:

; 573  :         }
; 574  :     }

	jmp	SHORT $LN2@scan_timer
$LN3@scan_timer:

; 575  :     return 0;

	xor	eax, eax
$LN1@scan_timer:

; 576  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_scan_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _get_timer
_TEXT	SEGMENT
tv74 = -196						; size = 4
_nr$ = 8						; size = 4
_get_timer PROC						; COMDAT

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 548  :     if (nr >= ACK_TIMER_ID || timer[nr] == 0)

	cmp	DWORD PTR _nr$[ebp], 128		; 00000080H
	jae	SHORT $LN3@get_timer
	mov	eax, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR _timer[eax*4], 0
	jne	SHORT $LN2@get_timer
$LN3@get_timer:

; 549  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@get_timer
$LN2@get_timer:

; 550  :     return timer[nr] > now ? timer[nr] - now : 0;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _timer[eax*4]
	cmp	ecx, DWORD PTR _now
	jle	SHORT $LN5@get_timer
	mov	edx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR _timer[edx*4]
	sub	eax, DWORD PTR _now
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN6@get_timer
$LN5@get_timer:
	mov	DWORD PTR tv74[ebp], 0
$LN6@get_timer:
	mov	eax, DWORD PTR tv74[ebp]
$LN1@get_timer:

; 551  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_get_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _recv_byte
_TEXT	SEGMENT
_blk$ = -20						; size = 4
_ch$ = -5						; size = 1
_recv_byte PROC						; COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 512  :     unsigned char ch;
; 513  :     struct BLK *blk = rblk_head;

	mov	eax, DWORD PTR _rblk_head
	mov	DWORD PTR _blk$[ebp], eax

; 514  : 
; 515  :     if (blk == NULL || blk->commit_ts > now) 

	cmp	DWORD PTR _blk$[ebp], 0
	je	SHORT $LN4@recv_byte
	mov	eax, DWORD PTR _blk$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _now
	jle	SHORT $LN5@recv_byte
$LN4@recv_byte:

; 516  :         ABORT("recv_byte(): Receiving Queue is empty");

	push	OFFSET ??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@recv_byte
$LN5@recv_byte:

; 517  : 
; 518  :     ch = blk->data[blk->rptr++];

	mov	eax, DWORD PTR _blk$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _blk$[ebp]
	mov	al, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR _ch$[ebp], al
	mov	ecx, DWORD PTR _blk$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _blk$[ebp]
	mov	DWORD PTR [eax+4], edx

; 519  :     if (blk->rptr == blk->wptr) {

	mov	eax, DWORD PTR _blk$[ebp]
	mov	ecx, DWORD PTR _blk$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN7@recv_byte

; 520  :         rblk_head = blk->link;

	mov	eax, DWORD PTR _blk$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _rblk_head, ecx

; 521  :         free(blk);

	mov	esi, esp
	mov	eax, DWORD PTR _blk$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@recv_byte:

; 522  :     } 
; 523  :     
; 524  :     return ch;

	mov	al, BYTE PTR _ch$[ebp]
$LN8@recv_byte:

; 525  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_recv_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _socket_recv
_TEXT	SEGMENT
tv210 = -268						; size = 8
tv94 = -268						; size = 8
tv236 = -264						; size = 4
tv194 = -264						; size = 4
_fact$1 = -64						; size = 8
_rate$2 = -48						; size = 8
_a$3 = -32						; size = 4
_p$ = -20						; size = 4
_blk$ = -8						; size = 4
_socket_recv PROC					; COMDAT

; 465  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 466  :     struct BLK *blk;
; 467  :     unsigned char *p;
; 468  : 
; 469  :     blk = (struct BLK *)malloc(sizeof(struct BLK));

	mov	esi, esp
	push	260					; 00000104H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _blk$[ebp], eax

; 470  :     if (blk == NULL) 

	cmp	DWORD PTR _blk$[ebp], 0
	jne	SHORT $LN3@socket_rec
$LN4@socket_rec:

; 471  :         ABORT("No enough memory");

	push	OFFSET ??_C@_0BB@IAFLKGG@No?5enough?5memory@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@socket_rec
$LN3@socket_rec:

; 472  : 
; 473  :     blk->rptr = 0;

	mov	eax, DWORD PTR _blk$[ebp]
	mov	DWORD PTR [eax+4], 0

; 474  :     blk->wptr = recv(sock, (char *)blk->data, BLKSIZE, 0);

	push	0
	push	242					; 000000f2H
	mov	eax, DWORD PTR _blk$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_recv@16
	mov	edx, DWORD PTR _blk$[ebp]
	mov	DWORD PTR [edx+8], eax

; 475  :     if (blk->wptr <= 0) {

	mov	eax, DWORD PTR _blk$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jg	SHORT $LN6@socket_rec

; 476  :         lprintf("TCP disconnected.\n");

	push	OFFSET ??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@
	call	_lprintf
	add	esp, 4

; 477  :         exit(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@socket_rec:

; 478  :     }
; 479  :     nbits += blk->wptr * 4;

	mov	eax, DWORD PTR _blk$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _nbits
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _nbits, eax

; 480  : 
; 481  :     /* Impose noise */
; 482  :     if (ber != 0.0) {

	movsd	xmm0, QWORD PTR _ber
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN9@socket_rec

; 483  :         int a;
; 484  :         double rate, fact;
; 485  : 
; 486  :         rate = (double)noise / nbits;

	cvtsi2sd xmm0, DWORD PTR _noise
	mov	eax, DWORD PTR _nbits
	mov	DWORD PTR tv194[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv194[ebp]
	mov	ecx, DWORD PTR tv194[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _rate$2[ebp], xmm0

; 487  :         fact = rate > ber ? 3.5 : 6.0;

	movsd	xmm0, QWORD PTR _rate$2[ebp]
	comisd	xmm0, QWORD PTR _ber
	jbe	SHORT $LN13@socket_rec
	movsd	xmm0, QWORD PTR __real@400c000000000000
	movsd	QWORD PTR tv94[ebp], xmm0
	jmp	SHORT $LN14@socket_rec
$LN13@socket_rec:
	movsd	xmm0, QWORD PTR __real@4018000000000000
	movsd	QWORD PTR tv94[ebp], xmm0
$LN14@socket_rec:
	movsd	xmm0, QWORD PTR tv94[ebp]
	movsd	QWORD PTR _fact$1[ebp], xmm0

; 488  :         a = (int)((1.0 - pow(1.0 - ber, fact * blk->wptr)) * (RAND_MAX + 1.0) + 0.5);

	mov	eax, DWORD PTR _blk$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+8]
	mulsd	xmm0, QWORD PTR _fact$1[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _ber
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv210[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR tv210[ebp]
	mulsd	xmm0, QWORD PTR __real@40e0000000000000
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _a$3[ebp], ecx

; 489  :         if (rand() <= a) {

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR _a$3[ebp]
	jg	$LN9@socket_rec

; 490  :             p = &blk->data[rand() % blk->wptr];

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _blk$[ebp]
	cdq
	idiv	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _blk$[ebp]
	lea	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _p$[ebp], ecx

; 491  :             if (*p & 0x0f) {

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 15					; 0000000fH
	je	$LN9@socket_rec

; 492  :                 *p ^= 1 << (rand() % 8);

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN15@socket_rec
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN15@socket_rec:
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, edx
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], cl

; 493  :                 noise++;

	mov	eax, DWORD PTR _noise
	add	eax, 1
	mov	DWORD PTR _noise, eax

; 494  :                 dbg_warning("Impose noise on received data, %u/%u=%.1E\n", noise, nbits, (double)noise / nbits);

	cvtsi2sd xmm0, DWORD PTR _noise
	mov	eax, DWORD PTR _nbits
	mov	DWORD PTR tv236[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv236[ebp]
	mov	ecx, DWORD PTR tv236[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _nbits
	push	edx
	mov	eax, DWORD PTR _noise
	push	eax
	push	OFFSET ??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@
	call	_dbg_warning
	add	esp, 20					; 00000014H
$LN9@socket_rec:

; 495  :             }
; 496  :         }
; 497  :     }
; 498  : 
; 499  :     blk->commit_ts = now + CHAN_DELAY - 10;

	mov	eax, DWORD PTR _now
	add	eax, 260				; 00000104H
	mov	ecx, DWORD PTR _blk$[ebp]
	mov	DWORD PTR [ecx], eax

; 500  :     blk->link = NULL; 

	mov	eax, DWORD PTR _blk$[ebp]
	mov	DWORD PTR [eax+12], 0

; 501  : 
; 502  :     if (rblk_head == NULL) 

	cmp	DWORD PTR _rblk_head, 0
	jne	SHORT $LN10@socket_rec

; 503  :         rblk_head = rblk_tail = blk;

	mov	eax, DWORD PTR _blk$[ebp]
	mov	DWORD PTR _rblk_tail, eax
	mov	ecx, DWORD PTR _rblk_tail
	mov	DWORD PTR _rblk_head, ecx
	jmp	SHORT $LN11@socket_rec
$LN10@socket_rec:

; 504  :     else {
; 505  :         rblk_tail->link = blk;

	mov	eax, DWORD PTR _rblk_tail
	mov	ecx, DWORD PTR _blk$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 506  :         rblk_tail = blk;

	mov	eax, DWORD PTR _blk$[ebp]
	mov	DWORD PTR _rblk_tail, eax
$LN11@socket_rec:

; 507  :     }
; 508  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_socket_recv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _socket_send
_TEXT	SEGMENT
_send_bytes$ = -32					; size = 4
_send_tail$ = -20					; size = 4
_n$ = -8						; size = 4
_socket_send PROC					; COMDAT

; 421  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 422  :     static int last_ts = 0;
; 423  :     int n, send_tail = sq_head, send_bytes;

	mov	eax, DWORD PTR _sq_head
	mov	DWORD PTR _send_tail$[ebp], eax

; 424  : 
; 425  :     if (last_ts == 0) 

	cmp	DWORD PTR ?last_ts@?1??socket_send@@9@9, 0
	jne	SHORT $LN2@socket_sen

; 426  :         last_ts = now;

	mov	eax, DWORD PTR _now
	mov	DWORD PTR ?last_ts@?1??socket_send@@9@9, eax
$LN2@socket_sen:

; 427  : 
; 428  :     if (now <= last_ts) 

	mov	eax, DWORD PTR _now
	cmp	eax, DWORD PTR ?last_ts@?1??socket_send@@9@9
	jg	SHORT $LN3@socket_sen

; 429  :         return;

	jmp	$LN1@socket_sen
$LN3@socket_sen:

; 430  : 
; 431  :     send_bytes_allowed = (now - last_ts) * CHAN_BPS / 8 / 1000 * 2;

	mov	eax, DWORD PTR _now
	sub	eax, DWORD PTR ?last_ts@?1??socket_send@@9@9
	imul	eax, eax, 8000
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	shl	eax, 1
	mov	DWORD PTR _send_bytes_allowed, eax

; 432  :     n = sq_len();

	call	_sq_len
	mov	DWORD PTR _n$[ebp], eax

; 433  :     if (n > send_bytes_allowed)

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _send_bytes_allowed
	jle	SHORT $LN4@socket_sen

; 434  :         n = send_bytes_allowed;

	mov	eax, DWORD PTR _send_bytes_allowed
	mov	DWORD PTR _n$[ebp], eax
$LN4@socket_sen:

; 435  :     sq_inc(send_tail, n);

	mov	eax, DWORD PTR _send_tail$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN8@socket_sen
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN8@socket_sen:
	mov	DWORD PTR _send_tail$[ebp], eax

; 436  : 
; 437  :     if (send_tail >= sq_head) 

	mov	eax, DWORD PTR _send_tail$[ebp]
	cmp	eax, DWORD PTR _sq_head
	jl	SHORT $LN5@socket_sen

; 438  :         send_bytes = send_sq_data(sq_head, send_tail);

	mov	eax, DWORD PTR _send_tail$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sq_head
	push	ecx
	call	_send_sq_data
	add	esp, 8
	mov	DWORD PTR _send_bytes$[ebp], eax
	jmp	SHORT $LN6@socket_sen
$LN5@socket_sen:

; 439  :     else {
; 440  :         send_bytes = send_sq_data(sq_head, SQ_SIZE);

	push	131072					; 00020000H
	mov	eax, DWORD PTR _sq_head
	push	eax
	call	_send_sq_data
	add	esp, 8
	mov	DWORD PTR _send_bytes$[ebp], eax

; 441  :         send_bytes += send_sq_data(0, send_tail);

	mov	eax, DWORD PTR _send_tail$[ebp]
	push	eax
	push	0
	call	_send_sq_data
	add	esp, 8
	add	eax, DWORD PTR _send_bytes$[ebp]
	mov	DWORD PTR _send_bytes$[ebp], eax
$LN6@socket_sen:

; 442  :     }
; 443  : 
; 444  :     sq_inc(sq_head, send_bytes);

	mov	eax, DWORD PTR _sq_head
	add	eax, DWORD PTR _send_bytes$[ebp]
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN9@socket_sen
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN9@socket_sen:
	mov	DWORD PTR _sq_head, eax

; 445  :     send_bytes_allowed -= send_bytes;

	mov	eax, DWORD PTR _send_bytes_allowed
	sub	eax, DWORD PTR _send_bytes$[ebp]
	mov	DWORD PTR _send_bytes_allowed, eax

; 446  : 
; 447  :     last_ts = now;

	mov	eax, DWORD PTR _now
	mov	DWORD PTR ?last_ts@?1??socket_send@@9@9, eax
$LN1@socket_sen:

; 448  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_socket_send ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _send_sq_data
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_start$ = 8						; size = 4
_end1$ = 12						; size = 4
_send_sq_data PROC					; COMDAT

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 406  :     int ret;
; 407  : 
; 408  :     if (start >= end1) 

	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR _end1$[ebp]
	jb	SHORT $LN2@send_sq_da

; 409  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN4@send_sq_da
$LN2@send_sq_da:

; 410  : 
; 411  :     ret = send(sock, (char *)&sq[start], end1 - start, 0);

	push	0
	mov	eax, DWORD PTR _end1$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, OFFSET _sq
	push	ecx
	mov	edx, DWORD PTR _sock
	push	edx
	call	_send@16
	mov	DWORD PTR _ret$[ebp], eax

; 412  :     if (ret <= 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jg	SHORT $LN3@send_sq_da

; 413  :         lprintf("TCP Disconnected.\n");

	push	OFFSET ??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@
	call	_lprintf
	add	esp, 4

; 414  :         exit(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@send_sq_da:

; 415  :     }
; 416  : 
; 417  :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN4@send_sq_da:

; 418  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_send_sq_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _send_byte
_TEXT	SEGMENT
_byte$ = 8						; size = 1
_send_byte PROC						; COMDAT

; 375  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 376  :     inform_phl_ready = 1;

	mov	DWORD PTR _inform_phl_ready, 1

; 377  : 
; 378  :     if (send_bytes_allowed && sq_head == sq_tail) {

	cmp	DWORD PTR _send_bytes_allowed, 0
	je	SHORT $LN5@send_byte
	mov	eax, DWORD PTR _sq_head
	cmp	eax, DWORD PTR _sq_tail
	jne	SHORT $LN5@send_byte

; 379  :         send(sock, (char *)&byte, 1, 0);

	push	0
	push	1
	lea	eax, DWORD PTR _byte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_send@16

; 380  :         send_bytes_allowed--;

	mov	eax, DWORD PTR _send_bytes_allowed
	sub	eax, 1
	mov	DWORD PTR _send_bytes_allowed, eax

; 381  :         return;

	jmp	SHORT $LN7@send_byte
$LN5@send_byte:

; 382  :     }
; 383  : 
; 384  :     if (sq_len() == SQ_SIZE - 1)

	call	_sq_len
	cmp	eax, 131071				; 0001ffffH
	jne	SHORT $LN6@send_byte
$LN4@send_byte:

; 385  :         ABORT("Physical Layer Sending Queue overflow");

	push	OFFSET ??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@send_byte
$LN6@send_byte:

; 386  : 
; 387  :     sq[sq_tail] = byte;

	mov	eax, DWORD PTR _sq_tail
	mov	cl, BYTE PTR _byte$[ebp]
	mov	BYTE PTR _sq[eax], cl

; 388  :     sq_inc(sq_tail, 1);

	mov	eax, DWORD PTR _sq_tail
	add	eax, 1
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN8@send_byte
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN8@send_byte:
	mov	DWORD PTR _sq_tail, eax
$LN7@send_byte:

; 389  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_send_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _sq_len
_TEXT	SEGMENT
_sq_len	PROC						; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 366  :     return (sq_tail + SQ_SIZE - sq_head) % SQ_SIZE;

	mov	eax, DWORD PTR _sq_tail
	add	eax, 131072				; 00020000H
	sub	eax, DWORD PTR _sq_head
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN3@sq_len
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN3@sq_len:

; 367  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sq_len	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _config
_TEXT	SEGMENT
tv179 = -1628						; size = 4
tv87 = -1628						; size = 4
tv148 = -1625						; size = 1
_opt$ = -1044						; size = 4
_fname$ = -1032						; size = 1024
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_config	PROC						; COMDAT

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1628				; 0000065cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1052]
	mov	ecx, 263				; 00000107H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 138  : 	char fname[1024];
; 139  : 	int opt;
; 140  : 
; 141  : 	if (argc < 2) {

	cmp	DWORD PTR _argc$[ebp], 2
	jge	SHORT $LN9@config
$usage$39:

; 142  : 	usage:
; 143  : 		printf("\nUsage:\n  %s <options> <station-name>\n", argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@
	call	_printf
	add	esp, 8

; 144  : 		printf(

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	59144					; 0000e708H
	push	OFFSET ??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@
	call	_printf
	add	esp, 16					; 00000010H

; 145  : 			"\nOptions : \n"
; 146  : 			"    -?, --help : print this\n"
; 147  : 			"    -u, --utopia : utopia channel (an error-free channel)\n"
; 148  : 			"    -f, --flood : flood traffic\n"
; 149  : 			"    -i, --ibib  : set station B layer 3 sender mode as IDLE-BUSY-IDLE-BUSY-...\n"
; 150  : 			"    -n, --nolog : do not create log file\n"
; 151  : 			"    -d, --debug=<0-7>: debug mask (bit0:event, bit1:frame, bit2:warning)\n"
; 152  : 			"    -p, --port=<port#> : TCP port number (default: %u)\n"
; 153  : 			"    -b, --ber=<ber> : Bit Error Rate (received data only)\n"
; 154  : 			"    -l, --log=<filename> : using assigned file as log file\n"
; 155  : 			"    -t, --ttl=<seconds> : set time-to-live\n"
; 156  : 			"\n"
; 157  : 			"i.e.\n"
; 158  : 			"    %s -fd3 -b 1e-4 A\n"
; 159  : 			"    %s --flood --debug=3 --ber=1e-4 A\n"
; 160  : 			"\n",
; 161  : 			DEFAULT_PORT, argv[0], argv[0]);
; 162  : 		exit(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@config:

; 163  : 	}
; 164  : 
; 165  : 	strcpy(fname, "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN2@config:

; 166  : 
; 167  : 	while ((opt = getopt_long(argc, argv, OPT_SHORT, intopts, NULL)) != -1) {

	push	0
	push	OFFSET _intopts
	push	OFFSET ??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@
	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ecx
	call	_getopt_int
	add	esp, 20					; 00000014H
	mov	DWORD PTR _opt$[ebp], eax
	cmp	DWORD PTR _opt$[ebp], -1
	je	$LN3@config

; 168  : 		switch (opt) {

	mov	eax, DWORD PTR _opt$[ebp]
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	sub	ecx, 63					; 0000003fH
	mov	DWORD PTR tv87[ebp], ecx
	cmp	DWORD PTR tv87[ebp], 54			; 00000036H
	ja	$LN21@config
	mov	edx, DWORD PTR tv87[ebp]
	movzx	eax, BYTE PTR $LN34@config[edx]
	jmp	DWORD PTR $LN35@config[eax*4]
$LN10@config:

; 169  : 		case '?':
; 170  : 			goto usage;

	jmp	$usage$39
$LN11@config:

; 171  : 
; 172  : 		case 'u':
; 173  : 			ber = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _ber, xmm0

; 174  : 			break;

	jmp	$LN4@config
$LN12@config:

; 175  : 
; 176  : 		case 'f':
; 177  : 			mode_flood = 1;

	mov	DWORD PTR _mode_flood, 1

; 178  : 			break;

	jmp	$LN4@config
$LN13@config:

; 179  : 
; 180  : 		case 'i':
; 181  : 			mode_ibib = 1;

	mov	DWORD PTR _mode_ibib, 1

; 182  : 			break;

	jmp	$LN4@config
$LN14@config:

; 183  : 
; 184  : 		case 'n':
; 185  : 			strcpy(fname, "nul");

	push	OFFSET ??_C@_03JODACOMD@nul@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 186  : 			break;

	jmp	$LN4@config
$LN15@config:

; 187  : 
; 188  : 		case 'd':
; 189  : 			debug_mask = atoi(optarg);

	mov	esi, esp
	mov	eax, DWORD PTR _optarg
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _debug_mask, eax

; 190  : 			break;

	jmp	$LN4@config
$LN16@config:

; 191  : 
; 192  : 		case 'p':
; 193  : 			port = (unsigned short)atoi(optarg);

	mov	esi, esp
	mov	eax, DWORD PTR _optarg
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	WORD PTR _port, ax

; 194  : 			break;

	jmp	$LN4@config
$LN17@config:

; 195  : 
; 196  : 		case 'b':
; 197  : 			ber = strtod(optarg, 0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _optarg
	push	eax
	call	DWORD PTR __imp__strtod
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	fstp	QWORD PTR _ber

; 198  : 			if (ber >= 1.0) {

	movsd	xmm0, QWORD PTR _ber
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN18@config

; 199  : 				printf("Bad BER %.3f\n", ber);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _ber
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@
	call	_printf
	add	esp, 12					; 0000000cH

; 200  : 				goto usage;

	jmp	$usage$39
$LN18@config:

; 201  : 			}
; 202  : 			break;

	jmp	SHORT $LN4@config
$LN19@config:

; 203  : 
; 204  : 		case 'l':
; 205  : 			strcpy(fname, optarg);

	mov	eax, DWORD PTR _optarg
	push	eax
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 206  : 			break;

	jmp	SHORT $LN4@config
$LN20@config:

; 207  : 
; 208  : 		case 't':
; 209  : 			mode_life = atoi(optarg) * 1000; /* ms */

	mov	esi, esp
	mov	eax, DWORD PTR _optarg
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	imul	ecx, eax, 1000
	mov	DWORD PTR _mode_life, ecx

; 210  : 			break;

	jmp	SHORT $LN4@config
$LN21@config:

; 211  : 
; 212  : 		default:
; 213  : 			printf("ERROR: Unsupported option\n");

	push	OFFSET ??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@
	call	_printf
	add	esp, 4

; 214  : 			goto usage;

	jmp	$usage$39
$LN4@config:

; 215  : 		}
; 216  : 	}

	jmp	$LN2@config
$LN3@config:

; 217  : 
; 218  : 	if (optind == argc) 

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _argc$[ebp]
	jne	SHORT $LN22@config

; 219  : 		goto usage;

	jmp	$usage$39
$LN22@config:

; 220  : 
; 221  : 	station = tolower(argv[optind++][0]);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optind
	mov	eax, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR tv148[ebp], al
	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx
	movsx	edx, BYTE PTR tv148[ebp]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__tolower
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _station, eax

; 222  : 	if (station != 'a' && station != 'b')

	cmp	DWORD PTR _station, 97			; 00000061H
	je	SHORT $LN7@config
	cmp	DWORD PTR _station, 98			; 00000062H
	je	SHORT $LN7@config
$LN8@config:

; 223  : 		ABORT("Station name must be 'A' or 'B'");

	push	OFFSET ??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN8@config
$LN7@config:

; 224  : 
; 225  : 	if (fname[0] == 0) {

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _fname$[ebp+ecx]
	test	edx, edx
	jne	$LN24@config

; 226  : 		strcpy(fname, argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 227  : 		if (stricmp(fname + strlen(fname) - 4, ".exe") == 0)

	mov	esi, esp
	push	OFFSET ??_C@_04JLMDILM@?4exe@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _fname$[ebp+eax-4]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN25@config

; 228  : 			*(fname + strlen(fname) - 4) = 0;

	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	BYTE PTR _fname$[ebp+eax-4], 0
$LN25@config:

; 229  : 		strcat(fname, station == 'a' ? "-A.log" : "-B.log");

	cmp	DWORD PTR _station, 97			; 00000061H
	jne	SHORT $LN32@config
	mov	DWORD PTR tv179[ebp], OFFSET ??_C@_06GOMLAJLH@?9A?4log@
	jmp	SHORT $LN33@config
$LN32@config:
	mov	DWORD PTR tv179[ebp], OFFSET ??_C@_06OIFPHLBJ@?9B?4log@
$LN33@config:
	mov	eax, DWORD PTR tv179[ebp]
	push	eax
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN24@config:

; 230  : 	}
; 231  : 
; 232  : 	if (stricmp(fname, "nul") == 0)

	mov	esi, esp
	push	OFFSET ??_C@_03JODACOMD@nul@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN26@config

; 233  : 		log_file = NULL;

	mov	DWORD PTR _log_file, 0
	jmp	SHORT $LN28@config
$LN26@config:

; 234  : 	else if ((log_file = fopen(fname, "w")) == NULL) 

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _log_file, eax
	cmp	DWORD PTR _log_file, 0
	jne	SHORT $LN28@config

; 235  : 		printf("WARNING: Failed to create log file \"%s\": %s\n", fname, strerror(errno));

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@
	call	_printf
	add	esp, 12					; 0000000cH
$LN28@config:

; 236  : 
; 237  : 	lprintf(

	call	_station_name
	push	eax
	push	OFFSET ??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	_lprintf
	add	esp, 8

; 238  : 		"=============================================================\n"
; 239  : 		"                    Station %s                               \n"
; 240  : 		"-------------------------------------------------------------\n",
; 241  : 		station_name());
; 242  : 
; 243  : 	lprintf("Protocol.lib, version %s, jiangyanjun0718@bupt.edu.cn\n", VERSION, __DATE__);

	push	OFFSET ??_C@_0M@LKGDGICL@May?520?52022@
	push	OFFSET ??_C@_03EMGHBCAM@4?40@
	push	OFFSET ??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@
	call	_lprintf
	add	esp, 12					; 0000000cH

; 244  : 	lprintf("Channel: %d bps, %d ms propagation delay, bit error rate ", CHAN_BPS, CHAN_DELAY);

	push	270					; 0000010eH
	push	8000					; 00001f40H
	push	OFFSET ??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@
	call	_lprintf
	add	esp, 12					; 0000000cH

; 245  : 	if (ber > 0.0)

	movsd	xmm0, QWORD PTR _ber
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN29@config

; 246  : 		lprintf("%.1E\n", ber);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _ber
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05KDIEGDNJ@?$CF?41E?6@
	call	_lprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@config
$LN29@config:

; 247  : 	else
; 248  : 		lprintf("0\n");

	push	OFFSET ??_C@_02NODKCLPH@0?6@
	call	_lprintf
	add	esp, 4
$LN30@config:

; 249  : 	lprintf("Log file \"%s\", TCP port %d, debug mask 0x%02x\n", fname, port, debug_mask);

	mov	eax, DWORD PTR _debug_mask
	push	eax
	movzx	ecx, WORD PTR _port
	push	ecx
	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@
	call	_lprintf
	add	esp, 16					; 00000010H
$LN1@config:

; 250  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN38@config
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1628				; 0000065cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN38@config:
	DD	1
	DD	$LN37@config
$LN37@config:
	DD	-1032					; fffffbf8H
	DD	1024					; 00000400H
	DD	$LN36@config
$LN36@config:
	DB	102					; 00000066H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
	npad	2
$LN35@config:
	DD	$LN10@config
	DD	$LN17@config
	DD	$LN15@config
	DD	$LN12@config
	DD	$LN13@config
	DD	$LN19@config
	DD	$LN14@config
	DD	$LN16@config
	DD	$LN20@config
	DD	$LN11@config
	DD	$LN21@config
$LN34@config:
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	10					; 0000000aH
	DB	6
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	9
_config	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _magic_check
_TEXT	SEGMENT
_i$ = -8						; size = 4
_magic_check PROC					; COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 908  :     int i;
; 909  : 
; 910  :     for (i = 0; i < NMAGIC; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@magic_chec
$LN2@magic_chec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@magic_chec:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@magic_chec

; 911  : 		if (head_magic[i] != HEAD_MAGIC)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _head_magic[eax*4], -1515854821 ; a5a5e41bH
	je	SHORT $LN11@magic_chec

; 912  : 			goto exit;

	jmp	SHORT $exit$14
$LN11@magic_chec:

; 913  :     }

	jmp	SHORT $LN2@magic_chec
$LN3@magic_chec:

; 914  : 
; 915  :     for (i = 0; i < NMAGIC; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@magic_chec
$LN5@magic_chec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@magic_chec:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN6@magic_chec

; 916  : 		if (foot_magic[i] != FOOT_MAGIC)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _foot_magic[eax*4], -183346598 ; f5125a5aH
	je	SHORT $LN12@magic_chec

; 917  : 			goto exit;

	jmp	SHORT $exit$14
$LN12@magic_chec:

; 918  :     }

	jmp	SHORT $LN5@magic_chec
$LN6@magic_chec:

; 919  : 	return;

	jmp	SHORT $LN13@magic_chec
$exit$14:

; 920  : 
; 921  : exit:
; 922  : 	ABORT("Memory used by 'protocol.lib' is corrupted by your program");

	push	OFFSET ??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $exit$14
$LN13@magic_chec:

; 923  : 
; 924  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_magic_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _magic_init
_TEXT	SEGMENT
_i$ = -8						; size = 4
_magic_init PROC					; COMDAT

; 898  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 899  :     int i;
; 900  :     for (i = 0; i < NMAGIC; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@magic_init
$LN2@magic_init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@magic_init:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN1@magic_init

; 901  :         head_magic[i] = HEAD_MAGIC;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _head_magic[eax*4], -1515854821 ; a5a5e41bH

; 902  :         foot_magic[i] = FOOT_MAGIC;;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _foot_magic[eax*4], -183346598 ; f5125a5aH

; 903  :     }

	jmp	SHORT $LN2@magic_init
$LN1@magic_init:

; 904  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_magic_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _dbg_warning
_TEXT	SEGMENT
_arg_ptr$ = -8						; size = 4
_fmt$ = 8						; size = 4
_dbg_warning PROC					; COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 709  : 	va_list arg_ptr;
; 710  : 
; 711  : 	if (debug_mask & DBG_WARNING) {

	mov	eax, DWORD PTR _debug_mask
	and	eax, 4
	je	SHORT $LN1@dbg_warnin

; 712  : 		va_start(arg_ptr, fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _arg_ptr$[ebp], eax

; 713  : 		__v_lprintf(fmt, arg_ptr);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	call	___v_lprintf
	add	esp, 8

; 714  : 		va_end(arg_ptr);

	mov	DWORD PTR _arg_ptr$[ebp], 0
$LN1@dbg_warnin:

; 715  : 	}
; 716  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_warning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _dbg_frame
_TEXT	SEGMENT
_arg_ptr$ = -8						; size = 4
_fmt$ = 8						; size = 4
_dbg_frame PROC						; COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 698  : 	va_list arg_ptr;
; 699  : 
; 700  : 	if (debug_mask & DBG_FRAME) {

	mov	eax, DWORD PTR _debug_mask
	and	eax, 2
	je	SHORT $LN1@dbg_frame

; 701  : 		va_start(arg_ptr, fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _arg_ptr$[ebp], eax

; 702  : 		__v_lprintf(fmt, arg_ptr);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	call	___v_lprintf
	add	esp, 8

; 703  : 		va_end(arg_ptr);

	mov	DWORD PTR _arg_ptr$[ebp], 0
$LN1@dbg_frame:

; 704  : 	}
; 705  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _dbg_event
_TEXT	SEGMENT
_arg_ptr$ = -8						; size = 4
_fmt$ = 8						; size = 4
_dbg_event PROC						; COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 687  : 	va_list arg_ptr;
; 688  : 
; 689  : 	if (debug_mask & DBG_FRAME) {

	mov	eax, DWORD PTR _debug_mask
	and	eax, 2
	je	SHORT $LN1@dbg_event

; 690  : 		va_start(arg_ptr, fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _arg_ptr$[ebp], eax

; 691  : 		__v_lprintf(fmt, arg_ptr);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	call	___v_lprintf
	add	esp, 8

; 692  : 		va_end(arg_ptr);

	mov	DWORD PTR _arg_ptr$[ebp], 0
$LN1@dbg_event:

; 693  : 	}
; 694  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _station_name
_TEXT	SEGMENT
tv66 = -200						; size = 4
tv67 = -196						; size = 4
_station_name PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-8]
	mov	ecx, 2
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 117  :     return (char *)(station == 'a' ? "A" : station == 'b' ? "B" : "XXX");

	cmp	DWORD PTR _station, 97			; 00000061H
	jne	SHORT $LN5@station_na
	mov	DWORD PTR tv67[ebp], OFFSET ??_C@_01FHEEJDEE@A@
	jmp	SHORT $LN6@station_na
$LN5@station_na:
	cmp	DWORD PTR _station, 98			; 00000062H
	jne	SHORT $LN3@station_na
	mov	DWORD PTR tv66[ebp], OFFSET ??_C@_01HMGJMAIH@B@
	jmp	SHORT $LN4@station_na
$LN3@station_na:
	mov	DWORD PTR tv66[ebp], OFFSET ??_C@_03MAMPKPPK@XXX@
$LN4@station_na:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], eax
$LN6@station_na:
	mov	eax, DWORD PTR tv67[ebp]

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 200				; 000000c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_station_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _stop_ack_timer
_TEXT	SEGMENT
_stop_ack_timer PROC					; COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 561  :     timer[ACK_TIMER_ID] = 0;

	mov	eax, 4
	shl	eax, 7
	mov	DWORD PTR _timer[eax], 0

; 562  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stop_ack_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _start_ack_timer
_TEXT	SEGMENT
_ms$ = 8						; size = 4
_start_ack_timer PROC					; COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 555  :     if (timer[ACK_TIMER_ID] == 0)

	mov	eax, 4
	shl	eax, 7
	cmp	DWORD PTR _timer[eax], 0
	jne	SHORT $LN1@start_ack_

; 556  :         timer[ACK_TIMER_ID] = now + ms;

	mov	eax, DWORD PTR _now
	add	eax, DWORD PTR _ms$[ebp]
	mov	ecx, 4
	shl	ecx, 7
	mov	DWORD PTR _timer[ecx], eax
$LN1@start_ack_:

; 557  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_start_ack_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _stop_timer
_TEXT	SEGMENT
_nr$ = 8						; size = 4
_stop_timer PROC					; COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 542  :     if (nr < ACK_TIMER_ID) 

	cmp	DWORD PTR _nr$[ebp], 128		; 00000080H
	jae	SHORT $LN1@stop_timer

; 543  :         timer[nr] = 0;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR _timer[eax*4], 0
$LN1@stop_timer:

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stop_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _start_timer
_TEXT	SEGMENT
_nr$ = 8						; size = 4
_ms$ = 12						; size = 4
_start_timer PROC					; COMDAT

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 535  :     if (nr >= ACK_TIMER_ID) 

	cmp	DWORD PTR _nr$[ebp], 128		; 00000080H
	jb	SHORT $LN5@start_time
$LN4@start_time:

; 536  :         ABORT("start_timer(): timer No. must be 0~128");

	push	OFFSET ??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@start_time
$LN5@start_time:

; 537  :     timer[nr] = now + phl_sq_len() * 8000 / CHAN_BPS + ms;

	call	_phl_sq_len
	imul	eax, eax, 8000
	cdq
	mov	ecx, 8000				; 00001f40H
	idiv	ecx
	add	eax, DWORD PTR _now
	add	eax, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR _timer[edx*4], eax
$LN6@start_time:

; 538  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_start_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _phl_sq_len
_TEXT	SEGMENT
_phl_sq_len PROC					; COMDAT

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 371  :     return sq_len();

	call	_sq_len

; 372  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_phl_sq_len ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _send_frame
_TEXT	SEGMENT
_i$ = -8						; size = 4
_frame$ = 8						; size = 4
_len$ = 12						; size = 4
_send_frame PROC					; COMDAT

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 393  :     int i;
; 394  : 
; 395  :     send_byte(0xff);

	push	255					; 000000ffH
	call	_send_byte
	add	esp, 4

; 396  :     
; 397  :     for (i = 0; i < len; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@send_frame
$LN2@send_frame:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@send_frame:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN3@send_frame

; 398  :         send_byte(frame[i] & 0x0f);

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 15					; 0000000fH
	push	ecx
	call	_send_byte
	add	esp, 4

; 399  :         send_byte((frame[i] & 0xf0) >> 4);

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 240				; 000000f0H
	sar	ecx, 4
	push	ecx
	call	_send_byte
	add	esp, 4

; 400  :     }

	jmp	SHORT $LN2@send_frame
$LN3@send_frame:

; 401  :     send_byte(0xff);

	push	255					; 000000ffH
	call	_send_byte
	add	esp, 4

; 402  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_send_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _recv_frame
_TEXT	SEGMENT
_msg$ = -288						; size = 256
_next$ = -24						; size = 4
_len$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_recv_frame PROC					; COMDAT

; 735  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 736  :     int len;
; 737  :     struct RCV_FRAME *next;
; 738  :     char msg[256];
; 739  : 
; 740  :     if (rf_head == NULL) 

	cmp	DWORD PTR _rf_head, 0
	jne	SHORT $LN8@recv_frame
$LN4@recv_frame:

; 741  :         ABORT("recv_frame(): Receiving Queue is empty");

	push	OFFSET ??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@recv_frame
$LN8@recv_frame:

; 742  : 
; 743  :     len = rf_head->len;

	mov	eax, DWORD PTR _rf_head
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _len$[ebp], ecx

; 744  : 
; 745  :     if (size < len) { 

	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN9@recv_frame

; 746  :         sprintf(msg, "recv_frame(): %d-byte buffer is too small to save %d-byte received frame", size, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN7@recv_frame:

; 747  :         ABORT(msg);

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@recv_frame
$LN9@recv_frame:

; 748  :     }
; 749  :     
; 750  :     memcpy(buf, rf_head->frame, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rf_head
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 751  : 
; 752  :     next = rf_head->link;

	mov	eax, DWORD PTR _rf_head
	mov	ecx, DWORD PTR [eax+2056]
	mov	DWORD PTR _next$[ebp], ecx

; 753  :     if (next == NULL) 

	cmp	DWORD PTR _next$[ebp], 0
	jne	SHORT $LN10@recv_frame

; 754  :         rf_tail = NULL;

	mov	DWORD PTR _rf_tail, 0
$LN10@recv_frame:

; 755  :     free(rf_head); 

	mov	esi, esp
	mov	eax, DWORD PTR _rf_head
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 756  :     rf_head = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _rf_head, eax

; 757  : 
; 758  :     return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN11@recv_frame:

; 759  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@recv_frame
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 484				; 000001e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@recv_frame:
	DD	1
	DD	$LN13@recv_frame
$LN13@recv_frame:
	DD	-288					; fffffee0H
	DD	256					; 00000100H
	DD	$LN12@recv_frame
$LN12@recv_frame:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	0
_recv_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _put_packet
_TEXT	SEGMENT
tv158 = -236						; size = 4
tv65 = -236						; size = 4
_bps$1 = -36						; size = 8
_my_rand$ = -20						; size = 4
_i$ = -8						; size = 4
_packet$ = 8						; size = 4
_len$ = 12						; size = 4
_put_packet PROC					; COMDAT

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 659  :     static int last_ts = 0;
; 660  :     int i, (*my_rand)(void) = station == 'a' ? randB : randA;

	cmp	DWORD PTR _station, 97			; 00000061H
	jne	SHORT $LN15@put_packet
	mov	DWORD PTR tv65[ebp], OFFSET _randB
	jmp	SHORT $LN16@put_packet
$LN15@put_packet:
	mov	DWORD PTR tv65[ebp], OFFSET _randA
$LN16@put_packet:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _my_rand$[ebp], eax

; 661  : 
; 662  :     if (len != PKT_LEN) 

	cmp	DWORD PTR _len$[ebp], 256		; 00000100H
	je	SHORT $LN3@put_packet
$LN4@put_packet:

; 663  :         ABORT("Bad Packet length");

	push	OFFSET ??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@put_packet
$LN3@put_packet:

; 664  : 
; 665  :     for (i = 2; i < PKT_LEN; i++) {

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN7@put_packet
$LN5@put_packet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@put_packet:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN6@put_packet

; 666  :         if (packet[i] != next_char()) 

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	esi, BYTE PTR [eax]
	mov	edi, esp
	call	DWORD PTR _my_rand$[ebp]
	cmp	edi, esp
	call	__RTC_CheckEsp
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN9@put_packet
$LN10@put_packet:

; 667  :             ABORT("Network Layer received a bad packet from data link layer");

	push	OFFSET ??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN10@put_packet
$LN9@put_packet:

; 668  :     }

	jmp	SHORT $LN5@put_packet
$LN6@put_packet:

; 669  :     rpackets++;

	mov	eax, DWORD PTR _rpackets
	add	eax, 1
	mov	DWORD PTR _rpackets, eax

; 670  :     rbytes += len;

	mov	eax, DWORD PTR _rbytes
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _rbytes, eax

; 671  : 
; 672  :     if (now - last_ts > 2000 && now > ts0 + 2000) {

	mov	eax, DWORD PTR _now
	sub	eax, DWORD PTR ?last_ts@?1??put_packet@@9@9
	cmp	eax, 2000				; 000007d0H
	jle	$LN13@put_packet
	mov	eax, DWORD PTR _ts0
	add	eax, 2000				; 000007d0H
	cmp	DWORD PTR _now, eax
	jle	$LN13@put_packet

; 673  :         double bps;
; 674  :         bps = (double)rbytes * 8 * 1000 / (now - ts0);

	cvtsi2sd xmm0, DWORD PTR _rbytes
	mulsd	xmm0, QWORD PTR __real@4020000000000000
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	mov	eax, DWORD PTR _now
	sub	eax, DWORD PTR _ts0
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsd	QWORD PTR _bps$1[ebp], xmm0

; 675  :         lprintf(".... %d packets received, %.0f bps, %.2f%%, Err %d (%.1e)\n", 

	cvtsi2sd xmm0, DWORD PTR _noise
	mov	eax, DWORD PTR _nbits
	mov	DWORD PTR tv158[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv158[ebp]
	mov	ecx, DWORD PTR tv158[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _noise
	push	edx
	movsd	xmm0, QWORD PTR _bps$1[ebp]
	divsd	xmm0, QWORD PTR __real@40bf400000000000
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _bps$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _rpackets
	push	eax
	push	OFFSET ??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@
	call	_lprintf
	add	esp, 36					; 00000024H

; 676  :             rpackets, bps, bps / CHAN_BPS * 100, noise, (double)noise/nbits);
; 677  :         last_ts = now;

	mov	eax, DWORD PTR _now
	mov	DWORD PTR ?last_ts@?1??put_packet@@9@9, eax
$LN13@put_packet:

; 678  :     }
; 679  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_put_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _get_packet
_TEXT	SEGMENT
tv65 = -232						; size = 4
_my_rand$ = -32						; size = 4
_len$ = -20						; size = 4
_i$ = -8						; size = 4
_packet$ = 8						; size = 4
_get_packet PROC					; COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 638  :     static int pkt_no = 0;
; 639  :     int i, len;
; 640  :     int (*my_rand)(void) = station == 'a' ? randA : randB;

	cmp	DWORD PTR _station, 97			; 00000061H
	jne	SHORT $LN10@get_packet
	mov	DWORD PTR tv65[ebp], OFFSET _randA
	jmp	SHORT $LN11@get_packet
$LN10@get_packet:
	mov	DWORD PTR tv65[ebp], OFFSET _randB
$LN11@get_packet:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _my_rand$[ebp], eax

; 641  : 
; 642  :     if (!layer3_ready)

	cmp	DWORD PTR _layer3_ready, 0
	jne	SHORT $LN8@get_packet
$LN4@get_packet:

; 643  :         ABORT("get_packet(): Network layer is not ready for a new packet");

	push	OFFSET ??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@get_packet
$LN8@get_packet:

; 644  :     
; 645  :     len = PKT_LEN;

	mov	DWORD PTR _len$[ebp], 256		; 00000100H

; 646  :     for (i = 2; i < len; i++)

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN7@get_packet
$LN5@get_packet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@get_packet:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN6@get_packet

; 647  :         packet[i] = next_char();

	mov	esi, esp
	call	DWORD PTR _my_rand$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN5@get_packet
$LN6@get_packet:

; 648  :     *(unsigned short *)packet = (station - 'a' + 1) * 10000 + (pkt_no++ % 10000);

	mov	eax, DWORD PTR _station
	sub	eax, 96					; 00000060H
	imul	ecx, eax, 10000
	mov	eax, DWORD PTR ?pkt_no@?1??get_packet@@9@9
	cdq
	mov	esi, 10000				; 00002710H
	idiv	esi
	add	ecx, edx
	mov	edx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR ?pkt_no@?1??get_packet@@9@9
	add	eax, 1
	mov	DWORD PTR ?pkt_no@?1??get_packet@@9@9, eax

; 649  : 
; 650  :     layer3_ready = 0;

	mov	DWORD PTR _layer3_ready, 0

; 651  : 
; 652  :     return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN9@get_packet:

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_get_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _disable_network_layer
_TEXT	SEGMENT
_disable_network_layer PROC				; COMDAT

; 589  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 590  :     network_layer_active = 0;

	mov	DWORD PTR _network_layer_active, 0

; 591  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_disable_network_layer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _enable_network_layer
_TEXT	SEGMENT
_enable_network_layer PROC				; COMDAT

; 584  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 585  :     network_layer_active = 1;

	mov	DWORD PTR _network_layer_active, 1

; 586  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_enable_network_layer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _wait_for_event
_TEXT	SEGMENT
tv345 = -1064						; size = 8
tv342 = -1056						; size = 8
_ms$1 = -660						; size = 4
_ticks$2 = -648						; size = 4
_t$3 = -636						; size = 4
_ms0$4 = -624						; size = 4
_ch$ = -609						; size = 1
_nfds$ = -600						; size = 4
_i$ = -588						; size = 4
_n$ = -576						; size = 4
_event$ = -564						; size = 4
_tm$ = -552						; size = 8
_wfd$ = -536						; size = 260
_rfd$ = -268						; size = 260
__$ArrayPad$ = -4					; size = 4
_arg$ = 8						; size = 4
_wait_for_event PROC					; COMDAT

; 762  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1064				; 00000428H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-680]
	mov	ecx, 170				; 000000aaH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@wait_for_e:

; 763  :     fd_set rfd, wfd;
; 764  :     struct timeval tm;
; 765  :     int event, n, i, nfds;
; 766  :     unsigned char ch;
; 767  : 
; 768  :     for (;;) {
; 769  : 
; 770  :         now = get_ms();

	call	_get_ms
	mov	DWORD PTR _now, eax

; 771  :      
; 772  :         /* commit received socket data */
; 773  :         if (rblk_head && rblk_head->commit_ts <= now) {

	cmp	DWORD PTR _rblk_head, 0
	je	$LN17@wait_for_e
	mov	eax, DWORD PTR _rblk_head
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _now
	jg	$LN17@wait_for_e

; 774  :             n = rblk_head->wptr - rblk_head->rptr;

	mov	eax, DWORD PTR _rblk_head
	mov	ecx, DWORD PTR _rblk_head
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _n$[ebp], edx

; 775  :             
; 776  :             if (ts0 == 0) {

	cmp	DWORD PTR _ts0, 0
	jne	SHORT $LN18@wait_for_e

; 777  :                 ts0 = now;

	mov	eax, DWORD PTR _now
	mov	DWORD PTR _ts0, eax

; 778  :                 if (ts0 >= n / 2)

	mov	eax, DWORD PTR _n$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _ts0, eax
	jl	SHORT $LN18@wait_for_e

; 779  :                     ts0 -= n / 2;

	mov	eax, DWORD PTR _n$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ts0
	sub	ecx, eax
	mov	DWORD PTR _ts0, ecx
$LN18@wait_for_e:

; 780  :             }
; 781  : 
; 782  :             for (i = 0; i < n; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@wait_for_e
$LN5@wait_for_e:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@wait_for_e:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$LN6@wait_for_e

; 783  :                 ch = recv_byte();

	call	_recv_byte
	mov	BYTE PTR _ch$[ebp], al

; 784  :                 if (ch == 0xff) {

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN20@wait_for_e

; 785  :                     if (rf_buf == NULL) 

	cmp	DWORD PTR _rf_buf, 0
	jne	SHORT $LN22@wait_for_e

; 786  :                         rf_buf = (struct RCV_FRAME *)calloc(1, sizeof(struct RCV_FRAME));

	mov	esi, esp
	push	2060					; 0000080cH
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rf_buf, eax
	jmp	SHORT $LN23@wait_for_e
$LN22@wait_for_e:

; 787  :                     else {
; 788  :                         if (rf_buf->len > 0) {

	mov	eax, DWORD PTR _rf_buf
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN23@wait_for_e

; 789  :                             if (rf_head == NULL) 

	cmp	DWORD PTR _rf_head, 0
	jne	SHORT $LN25@wait_for_e

; 790  :                                 rf_head = rf_tail = rf_buf;

	mov	eax, DWORD PTR _rf_buf
	mov	DWORD PTR _rf_tail, eax
	mov	ecx, DWORD PTR _rf_tail
	mov	DWORD PTR _rf_head, ecx
	jmp	SHORT $LN26@wait_for_e
$LN25@wait_for_e:

; 791  :                             else {
; 792  :                                 rf_tail->link = rf_buf;

	mov	eax, DWORD PTR _rf_tail
	mov	ecx, DWORD PTR _rf_buf
	mov	DWORD PTR [eax+2056], ecx

; 793  :                                 rf_tail = rf_buf;

	mov	eax, DWORD PTR _rf_buf
	mov	DWORD PTR _rf_tail, eax
$LN26@wait_for_e:

; 794  :                             }
; 795  :                             rf_buf = NULL;

	mov	DWORD PTR _rf_buf, 0
$LN23@wait_for_e:

; 796  :                         }
; 797  :                     }

	jmp	$LN21@wait_for_e
$LN20@wait_for_e:

; 798  :                 } else if (rf_buf && rf_buf->len < sizeof(rf_buf->frame)) {

	cmp	DWORD PTR _rf_buf, 0
	je	$LN21@wait_for_e
	mov	eax, DWORD PTR _rf_buf
	cmp	DWORD PTR [eax], 2048			; 00000800H
	jae	$LN21@wait_for_e

; 799  :                     if (rf_buf->state == 0) {

	mov	eax, DWORD PTR _rf_buf
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN28@wait_for_e

; 800  :                         rf_buf->frame[rf_buf->len] = ch;

	mov	eax, DWORD PTR _rf_buf
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _rf_buf
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx+8], al

; 801  :                         rf_buf->state = 1;

	mov	eax, DWORD PTR _rf_buf
	mov	DWORD PTR [eax+4], 1

; 802  :                     } else {

	jmp	SHORT $LN21@wait_for_e
$LN28@wait_for_e:

; 803  :                         rf_buf->frame[rf_buf->len] |= (ch << 4) ^ (ch & 0xf0);

	mov	eax, DWORD PTR _rf_buf
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR _ch$[ebp]
	shl	edx, 4
	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 240				; 000000f0H
	xor	edx, eax
	mov	eax, DWORD PTR _rf_buf
	movzx	ecx, BYTE PTR [eax+ecx+8]
	or	ecx, edx
	mov	edx, DWORD PTR _rf_buf
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _rf_buf
	mov	BYTE PTR [edx+eax+8], cl

; 804  :                         rf_buf->len++;

	mov	eax, DWORD PTR _rf_buf
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _rf_buf
	mov	DWORD PTR [edx], ecx

; 805  :                         rf_buf->state = 0;

	mov	eax, DWORD PTR _rf_buf
	mov	DWORD PTR [eax+4], 0
$LN21@wait_for_e:

; 806  :                     }
; 807  :                 }
; 808  :             }

	jmp	$LN5@wait_for_e
$LN6@wait_for_e:

; 809  : 
; 810  :             if (rf_head)

	cmp	DWORD PTR _rf_head, 0
	je	SHORT $LN17@wait_for_e

; 811  :                 return FRAME_RECEIVED;

	mov	eax, 2
	jmp	$LN48@wait_for_e
$LN17@wait_for_e:

; 812  :         }
; 813  :         
; 814  :         /* test socket send/receive */
; 815  :         tm.tv_sec = tm.tv_usec = 0;

	mov	DWORD PTR _tm$[ebp+4], 0
	mov	eax, DWORD PTR _tm$[ebp+4]
	mov	DWORD PTR _tm$[ebp], eax

; 816  :         FD_ZERO(&rfd);

	mov	DWORD PTR _rfd$[ebp], 0

; 817  :         FD_ZERO(&wfd);

	mov	DWORD PTR _wfd$[ebp], 0
$LN10@wait_for_e:

; 818  :         FD_SET(sock, &rfd);

	cmp	DWORD PTR _rfd$[ebp], 64		; 00000040H
	jae	SHORT $LN8@wait_for_e
	mov	eax, DWORD PTR _rfd$[ebp]
	mov	ecx, DWORD PTR _sock
	mov	DWORD PTR _rfd$[ebp+eax*4+4], ecx
	mov	edx, DWORD PTR _rfd$[ebp]
	add	edx, 1
	mov	DWORD PTR _rfd$[ebp], edx
$LN8@wait_for_e:
	xor	eax, eax
	jne	SHORT $LN10@wait_for_e
$LN13@wait_for_e:

; 819  :         FD_SET(sock, &wfd);

	cmp	DWORD PTR _wfd$[ebp], 64		; 00000040H
	jae	SHORT $LN11@wait_for_e
	mov	eax, DWORD PTR _wfd$[ebp]
	mov	ecx, DWORD PTR _sock
	mov	DWORD PTR _wfd$[ebp+eax*4+4], ecx
	mov	edx, DWORD PTR _wfd$[ebp]
	add	edx, 1
	mov	DWORD PTR _wfd$[ebp], edx
$LN11@wait_for_e:
	xor	eax, eax
	jne	SHORT $LN13@wait_for_e

; 820  : 
; 821  :         nfds = (int)(sock + 1);

	mov	eax, DWORD PTR _sock
	add	eax, 1
	mov	DWORD PTR _nfds$[ebp], eax

; 822  :         if (select(nfds, &rfd, &wfd, 0, &tm) < 0) 

	lea	eax, DWORD PTR _tm$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _wfd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rfd$[ebp]
	push	edx
	mov	eax, DWORD PTR _nfds$[ebp]
	push	eax
	call	_select@20
	test	eax, eax
	jge	SHORT $LN33@wait_for_e
$LN16@wait_for_e:

; 823  :             ABORT("system select()");

	push	OFFSET ??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN16@wait_for_e
$LN33@wait_for_e:

; 824  :          
; 825  :         /* socket send */
; 826  :         if (FD_ISSET(sock, &wfd)) 

	lea	eax, DWORD PTR _wfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN34@wait_for_e

; 827  :             socket_send();

	call	_socket_send
$LN34@wait_for_e:

; 828  : 
; 829  :         /* socket receive */
; 830  :         if (FD_ISSET(sock, &rfd)) 

	lea	eax, DWORD PTR _rfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN35@wait_for_e

; 831  :             socket_recv();

	call	_socket_recv
$LN35@wait_for_e:

; 832  : 
; 833  :         /* network layer event */
; 834  :         if (network_layer_ready()) {

	call	_network_layer_ready
	test	eax, eax
	je	SHORT $LN36@wait_for_e

; 835  :             layer3_ready = 1;

	mov	DWORD PTR _layer3_ready, 1

; 836  :             return NETWORK_LAYER_READY;

	xor	eax, eax
	jmp	$LN48@wait_for_e
$LN36@wait_for_e:

; 837  :         }
; 838  : 
; 839  :         /* check all timers */
; 840  :         if ((event = scan_timer(arg)) != 0)

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_scan_timer
	add	esp, 4
	mov	DWORD PTR _event$[ebp], eax
	cmp	DWORD PTR _event$[ebp], 0
	je	SHORT $LN37@wait_for_e

; 841  :             return event;

	mov	eax, DWORD PTR _event$[ebp]
	jmp	$LN48@wait_for_e
$LN37@wait_for_e:

; 842  : 
; 843  :         /* physical layer event */
; 844  :         if (inform_phl_ready && phl_sq_len()  < PHL_SQ_LEVEL) {

	cmp	DWORD PTR _inform_phl_ready, 0
	je	SHORT $LN38@wait_for_e
	call	_phl_sq_len
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN38@wait_for_e

; 845  :             inform_phl_ready = 0;

	mov	DWORD PTR _inform_phl_ready, 0

; 846  :             return PHYSICAL_LAYER_READY;

	mov	eax, 1
	jmp	$LN48@wait_for_e
$LN38@wait_for_e:

; 847  :         }
; 848  : 
; 849  :         /* delay 'mode_tick' ms */
; 850  :         if (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN39@wait_for_e

; 851  :             int ms0, t;
; 852  :             static time_t last_warn;
; 853  :             ms0 = get_ms();

	call	_get_ms
	mov	DWORD PTR _ms0$4[ebp], eax

; 854  :             magic_check();

	call	_magic_check

; 855  :             Sleep(mode_tick);

	mov	esi, esp
	mov	eax, DWORD PTR _mode_tick
	push	eax
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 856  :             t = get_ms() - ms0;

	call	_get_ms
	sub	eax, DWORD PTR _ms0$4[ebp]
	mov	DWORD PTR _t$3[ebp], eax

; 857  :             if (t > mode_tick + 50 && time(0) > last_warn + 1) {

	mov	eax, DWORD PTR _mode_tick
	add	eax, 50					; 00000032H
	cmp	DWORD PTR _t$3[ebp], eax
	jle	$LN41@wait_for_e
	push	0
	call	_time
	add	esp, 4
	mov	ecx, DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9
	add	ecx, 1
	mov	esi, DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9+4
	adc	esi, 0
	mov	DWORD PTR tv342[ebp], eax
	mov	DWORD PTR tv342[ebp+4], edx
	mov	DWORD PTR tv345[ebp], ecx
	mov	DWORD PTR tv345[ebp+4], esi
	mov	edx, DWORD PTR tv342[ebp+4]
	cmp	edx, DWORD PTR tv345[ebp+4]
	jl	SHORT $LN41@wait_for_e
	jg	SHORT $LN49@wait_for_e
	mov	eax, DWORD PTR tv342[ebp]
	cmp	eax, DWORD PTR tv345[ebp]
	jbe	SHORT $LN41@wait_for_e
$LN49@wait_for_e:

; 858  :                 lprintf("** WARNING: System too busy, sleep %d ms, but be awakened %d ms later\n", 

	mov	eax, DWORD PTR _t$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _mode_tick
	push	ecx
	push	OFFSET ??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@
	call	_lprintf
	add	esp, 12					; 0000000cH

; 859  :                     mode_tick, t);
; 860  :                 last_warn = time(0);

	push	0
	call	_time
	add	esp, 4
	mov	DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9, eax
	mov	DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9+4, edx
$LN41@wait_for_e:

; 861  :             }
; 862  :         } else {

	jmp	$LN40@wait_for_e
$LN39@wait_for_e:

; 863  :             int ticks, ms;
; 864  : 
; 865  :             sleep_cnt++;

	mov	eax, DWORD PTR _sleep_cnt
	add	eax, 1
	mov	DWORD PTR _sleep_cnt, eax

; 866  : 
; 867  :             ms = get_ms();

	call	_get_ms
	mov	DWORD PTR _ms$1[ebp], eax

; 868  :             if (start_ms == 0)

	cmp	DWORD PTR _start_ms, 0
	jne	SHORT $LN42@wait_for_e

; 869  :                 start_ms = ms;

	mov	eax, DWORD PTR _ms$1[ebp]
	mov	DWORD PTR _start_ms, eax
	jmp	$LN43@wait_for_e
$LN42@wait_for_e:

; 870  :             else if (ms - wakeup_ms > 1) {

	mov	eax, DWORD PTR _ms$1[ebp]
	sub	eax, DWORD PTR _wakeup_ms
	cmp	eax, 1
	jle	SHORT $LN43@wait_for_e

; 871  :                 ticks = (ms - start_ms) / mode_tick;

	mov	eax, DWORD PTR _ms$1[ebp]
	sub	eax, DWORD PTR _start_ms
	cdq
	idiv	DWORD PTR _mode_tick
	mov	DWORD PTR _ticks$2[ebp], eax

; 872  :                 lprintf("====== CPU BUSY for %d ms (cnt %d)\n", ms - wakeup_ms, ++busy_cnt);

	mov	eax, DWORD PTR _busy_cnt
	add	eax, 1
	mov	DWORD PTR _busy_cnt, eax
	mov	ecx, DWORD PTR _busy_cnt
	push	ecx
	mov	edx, DWORD PTR _ms$1[ebp]
	sub	edx, DWORD PTR _wakeup_ms
	push	edx
	push	OFFSET ??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@
	call	_lprintf
	add	esp, 12					; 0000000cH

; 873  :                 lprintf("------ noSleep %d, sleep %d, Elapse %d ticks\n", ticks - sleep_cnt, sleep_cnt, ticks);

	mov	eax, DWORD PTR _ticks$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _sleep_cnt
	push	ecx
	mov	edx, DWORD PTR _ticks$2[ebp]
	sub	edx, DWORD PTR _sleep_cnt
	push	edx
	push	OFFSET ??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@
	call	_lprintf
	add	esp, 16					; 00000010H
$LN43@wait_for_e:

; 874  :             }
; 875  : 
; 876  :             magic_check();

	call	_magic_check

; 877  :             ms = get_ms();

	call	_get_ms
	mov	DWORD PTR _ms$1[ebp], eax

; 878  :             Sleep(mode_tick);

	mov	esi, esp
	mov	eax, DWORD PTR _mode_tick
	push	eax
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 879  :             wakeup_ms = get_ms();

	call	_get_ms
	mov	DWORD PTR _wakeup_ms, eax

; 880  : 
; 881  :             ms = wakeup_ms - ms;

	mov	eax, DWORD PTR _wakeup_ms
	sub	eax, DWORD PTR _ms$1[ebp]
	mov	DWORD PTR _ms$1[ebp], eax

; 882  :             if (ms > mode_tick + 1 || ms < mode_tick - 1) 

	mov	eax, DWORD PTR _mode_tick
	add	eax, 1
	cmp	DWORD PTR _ms$1[ebp], eax
	jg	SHORT $LN46@wait_for_e
	mov	eax, DWORD PTR _mode_tick
	sub	eax, 1
	cmp	DWORD PTR _ms$1[ebp], eax
	jge	SHORT $LN40@wait_for_e
$LN46@wait_for_e:

; 883  :                 lprintf("++++++ Sleep(%d)=%d+%d (cnt %d)\n", mode_tick, mode_tick, ms - mode_tick, ++bias_cnt);

	mov	eax, DWORD PTR _bias_cnt
	add	eax, 1
	mov	DWORD PTR _bias_cnt, eax
	mov	ecx, DWORD PTR _bias_cnt
	push	ecx
	mov	edx, DWORD PTR _ms$1[ebp]
	sub	edx, DWORD PTR _mode_tick
	push	edx
	mov	eax, DWORD PTR _mode_tick
	push	eax
	mov	ecx, DWORD PTR _mode_tick
	push	ecx
	push	OFFSET ??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@
	call	_lprintf
	add	esp, 20					; 00000014H
$LN40@wait_for_e:

; 884  :         }
; 885  : 
; 886  :         if (now > mode_life) {

	mov	eax, DWORD PTR _now
	cmp	eax, DWORD PTR _mode_life
	jle	SHORT $LN47@wait_for_e

; 887  :             lprintf("Quit.\n");

	push	OFFSET ??_C@_06EJNPPGH@Quit?4?6@
	call	_lprintf
	add	esp, 4

; 888  :             exit(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@wait_for_e:

; 889  :         }
; 890  :     }

	jmp	$LN4@wait_for_e
$LN48@wait_for_e:

; 891  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN54@wait_for_e
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1064				; 00000428H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN54@wait_for_e:
	DD	3
	DD	$LN53@wait_for_e
$LN53@wait_for_e:
	DD	-268					; fffffef4H
	DD	260					; 00000104H
	DD	$LN50@wait_for_e
	DD	-536					; fffffde8H
	DD	260					; 00000104H
	DD	$LN51@wait_for_e
	DD	-552					; fffffdd8H
	DD	8
	DD	$LN52@wait_for_e
$LN52@wait_for_e:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	0
$LN51@wait_for_e:
	DB	119					; 00000077H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN50@wait_for_e:
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
_wait_for_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _protocol_init
_TEXT	SEGMENT
_on$1 = -96						; size = 4
_buf_size$2 = -84					; size = 4
_timeout_ms$3 = -72					; size = 4
_newtime$4 = -60					; size = 4
_name$ = -48						; size = 16
_i$ = -24						; size = 4
_admin_sock$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_protocol_init PROC					; COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 256  : 	SOCKET admin_sock;
; 257  : 	int i;
; 258  :     struct sockaddr_in name;
; 259  : 
; 260  : 	socket_init();

	call	_socket_init

; 261  : 	magic_init();

	call	_magic_init

; 262  : 
; 263  : 	config(argc, argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ecx
	call	_config
	add	esp, 8

; 264  :   
; 265  :     if (station == 'a') {

	cmp	DWORD PTR _station, 97			; 00000061H
	jne	$LN20@protocol_i

; 266  : 
; 267  :         srand(mode_seed ^ 97209);

	mov	eax, DWORD PTR _mode_seed
	xor	eax, 97209				; 00017bb9H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 268  : 
; 269  :         name.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR _name$[ebp], ax

; 270  :         name.sin_addr.s_addr = INADDR_ANY;

	mov	DWORD PTR _name$[ebp+4], 0

; 271  :         name.sin_port = htons(port);

	movzx	eax, WORD PTR _port
	push	eax
	call	_htons@4
	mov	WORD PTR _name$[ebp+2], ax

; 272  : 
; 273  :         admin_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _admin_sock$[ebp], eax

; 274  :         if (admin_sock < 0) 

	cmp	DWORD PTR _admin_sock$[ebp], 0
	jae	SHORT $LN21@protocol_i
$LN4@protocol_i:

; 275  :             ABORT("Create TCP socket");

	push	OFFSET ??_C@_0BC@BNICANMP@Create?5TCP?5socket@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN4@protocol_i
$LN21@protocol_i:

; 276  :         if (bind(admin_sock, (struct sockaddr *)&name, sizeof(name)) < 0) {

	push	16					; 00000010H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _admin_sock$[ebp]
	push	ecx
	call	_bind@12
	test	eax, eax
	jge	SHORT $LN22@protocol_i

; 277  :             lprintf("Station A: Failed to bind TCP port %u", port);

	movzx	eax, WORD PTR _port
	push	eax
	push	OFFSET ??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@
	call	_lprintf
	add	esp, 8
$LN7@protocol_i:

; 278  :             ABORT("Station A failed to bind TCP port");

	push	OFFSET ??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@protocol_i
$LN22@protocol_i:

; 279  :         }
; 280  : 
; 281  :         listen(admin_sock, 5);

	push	5
	mov	eax, DWORD PTR _admin_sock$[ebp]
	push	eax
	call	_listen@8

; 282  : 
; 283  :         lprintf("Station A is waiting for station B on TCP port %u ... ", port);

	movzx	eax, WORD PTR _port
	push	eax
	push	OFFSET ??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@
	call	_lprintf
	add	esp, 8

; 284  :         fflush(stdout);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 285  : 
; 286  :         sock = accept(admin_sock, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _admin_sock$[ebp]
	push	eax
	call	_accept@12
	mov	DWORD PTR _sock, eax

; 287  :         if (sock < 0) 

	cmp	DWORD PTR _sock, 0
	jae	SHORT $LN23@protocol_i
$LN10@protocol_i:

; 288  :             ABORT("Station A failed to communicate with station B");

	push	OFFSET ??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN10@protocol_i
$LN23@protocol_i:

; 289  :         lprintf("Done.\n");

	push	OFFSET ??_C@_06MJLDIBBJ@Done?4?6@
	call	_lprintf
	add	esp, 4

; 290  : 
; 291  :         recv(sock, (char *)&epoch, sizeof(epoch), 0);

	push	0
	push	8
	push	OFFSET _epoch
	mov	eax, DWORD PTR _sock
	push	eax
	call	_recv@16
$LN20@protocol_i:

; 292  :     }
; 293  : 
; 294  :     if (station == 'b') {

	cmp	DWORD PTR _station, 98			; 00000062H
	jne	$LN24@protocol_i

; 295  : 
; 296  :         srand(mode_seed ^ 18231);

	mov	eax, DWORD PTR _mode_seed
	xor	eax, 18231				; 00004737H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 297  : 
; 298  :         sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _sock, eax

; 299  :         if (sock < 0) 

	cmp	DWORD PTR _sock, 0
	jae	SHORT $LN25@protocol_i
$LN13@protocol_i:

; 300  :             ABORT("Create TCP socket");

	push	OFFSET ??_C@_0BC@BNICANMP@Create?5TCP?5socket@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN13@protocol_i
$LN25@protocol_i:

; 301  : 
; 302  :         name.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR _name$[ebp], ax

; 303  :         name.sin_addr.s_addr = inet_addr("127.0.0.1");

	push	OFFSET ??_C@_09PFCHIMEP@127?40?40?41@
	call	_inet_addr@4
	mov	DWORD PTR _name$[ebp+4], eax

; 304  :         name.sin_port = htons((short)port);

	movzx	eax, WORD PTR _port
	push	eax
	call	_htons@4
	mov	WORD PTR _name$[ebp+2], ax

; 305  : 
; 306  :         for (i = 0; i < 60; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@protocol_i
$LN14@protocol_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@protocol_i:
	cmp	DWORD PTR _i$[ebp], 60			; 0000003cH
	jge	$LN15@protocol_i

; 307  :             lprintf("Station B is connecting station A (TCP port %u) ... ", port);

	movzx	eax, WORD PTR _port
	push	eax
	push	OFFSET ??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@
	call	_lprintf
	add	esp, 8

; 308  :             fflush(stdout);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 309  : 
; 310  :             if (connect(sock, (struct sockaddr *)&name, sizeof(struct sockaddr_in)) < 0) {

	push	16					; 00000010H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_connect@12
	test	eax, eax
	jge	SHORT $LN26@protocol_i

; 311  :                 lprintf("Failed!\n");

	push	OFFSET ??_C@_08OPNBKLNK@Failed?$CB?6@
	call	_lprintf
	add	esp, 4

; 312  :                 Sleep(2000);

	mov	esi, esp
	push	2000					; 000007d0H
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 313  :             } else {

	jmp	SHORT $LN27@protocol_i
$LN26@protocol_i:

; 314  :                 lprintf("Done.\n");

	push	OFFSET ??_C@_06MJLDIBBJ@Done?4?6@
	call	_lprintf
	add	esp, 4

; 315  :                 break;

	jmp	SHORT $LN15@protocol_i
$LN27@protocol_i:

; 316  :             }
; 317  :         }

	jmp	$LN14@protocol_i
$LN15@protocol_i:

; 318  :         if (i == 6)

	cmp	DWORD PTR _i$[ebp], 6
	jne	SHORT $LN28@protocol_i
$LN19@protocol_i:

; 319  :             ABORT("Station B failed to connect station A");

	push	OFFSET ??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN19@protocol_i
$LN28@protocol_i:

; 320  : 
; 321  :         time(&epoch);

	push	OFFSET _epoch
	call	_time
	add	esp, 4

; 322  :         send(sock, (char *)&epoch, sizeof(epoch), 0);

	push	0
	push	8
	push	OFFSET _epoch
	mov	eax, DWORD PTR _sock
	push	eax
	call	_send@16
$LN24@protocol_i:

; 323  :     }
; 324  : 
; 325  :     {
; 326  :         struct tm *newtime;
; 327  :         newtime = localtime(&epoch);

	push	OFFSET _epoch
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _newtime$4[ebp], eax

; 328  :         lprintf("New epoch: %s", asctime(newtime));

	mov	esi, esp
	mov	eax, DWORD PTR _newtime$4[ebp]
	push	eax
	call	DWORD PTR __imp__asctime
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@
	call	_lprintf
	add	esp, 8

; 329  :         lprintf("=================================================================\n\n");

	push	OFFSET ??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	_lprintf
	add	esp, 4

; 330  :     }
; 331  : 
; 332  :     /* socket options */
; 333  :     {
; 334  :         int timeout_ms = 10; 

	mov	DWORD PTR _timeout_ms$3[ebp], 10	; 0000000aH

; 335  :         int buf_size = 1024 * 64;

	mov	DWORD PTR _buf_size$2[ebp], 65536	; 00010000H

; 336  :         int on = 1;

	mov	DWORD PTR _on$1[ebp], 1

; 337  : 
; 338  :         setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout_ms, sizeof(int));

	push	4
	lea	eax, DWORD PTR _timeout_ms$3[ebp]
	push	eax
	push	4101					; 00001005H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_setsockopt@20

; 339  :         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout_ms, sizeof(int));

	push	4
	lea	eax, DWORD PTR _timeout_ms$3[ebp]
	push	eax
	push	4102					; 00001006H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_setsockopt@20

; 340  : 
; 341  :         setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&buf_size, sizeof(int));

	push	4
	lea	eax, DWORD PTR _buf_size$2[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_setsockopt@20

; 342  :         setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *)&buf_size, sizeof(int));

	push	4
	lea	eax, DWORD PTR _buf_size$2[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_setsockopt@20

; 343  : 
; 344  :         setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof(on));   

	push	4
	lea	eax, DWORD PTR _on$1[ebp]
	push	eax
	push	1
	push	6
	mov	ecx, DWORD PTR _sock
	push	ecx
	call	_setsockopt@20

; 345  :     }   
; 346  : 
; 347  :     get_ms();

	call	_get_ms
$LN29@protocol_i:

; 348  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN35@protocol_i
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@protocol_i:
	DD	4
	DD	$LN34@protocol_i
$LN34@protocol_i:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN30@protocol_i
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN31@protocol_i
	DD	-84					; ffffffacH
	DD	4
	DD	$LN32@protocol_i
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN33@protocol_i
$LN33@protocol_i:
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN32@protocol_i:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN31@protocol_i:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	0
$LN30@protocol_i:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_protocol_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _get_ms
_TEXT	SEGMENT
tv71 = -228						; size = 8
_tm$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_get_ms	PROC						; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 37   : 	struct _timeb tm;
; 38   : 
; 39   : 	_ftime(&tm);

	mov	esi, esp
	lea	eax, DWORD PTR _tm$[ebp]
	push	eax
	call	DWORD PTR __imp___ftime64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 40   : 
; 41   : 	return (unsigned int)(epoch ? (tm.time - epoch) * 1000 + tm.millitm : 0);

	mov	eax, DWORD PTR _epoch
	or	eax, DWORD PTR _epoch+4
	je	SHORT $LN3@get_ms
	mov	ecx, DWORD PTR _tm$[ebp]
	sub	ecx, DWORD PTR _epoch
	mov	edx, DWORD PTR _tm$[ebp+4]
	sbb	edx, DWORD PTR _epoch+4
	push	0
	push	1000					; 000003e8H
	push	edx
	push	ecx
	call	__allmul
	mov	ecx, eax
	mov	esi, edx
	movzx	eax, WORD PTR _tm$[ebp+8]
	cdq
	add	ecx, eax
	adc	esi, edx
	mov	DWORD PTR tv71[ebp], ecx
	mov	DWORD PTR tv71[ebp+4], esi
	jmp	SHORT $LN4@get_ms
$LN3@get_ms:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv71[ebp], xmm0
$LN4@get_ms:
	mov	eax, DWORD PTR tv71[ebp]

; 42   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@get_ms
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@get_ms:
	DD	1
	DD	$LN6@get_ms
$LN6@get_ms:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN5@get_ms
$LN5@get_ms:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	0
_get_ms	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\protocol.c
;	COMDAT _socket_init
_TEXT	SEGMENT
_status$ = -432						; size = 4
_WSAData$ = -420					; size = 400
_wVersionRequested$ = -12				; size = 2
__$ArrayPad$ = -4					; size = 4
_socket_init PROC					; COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 628				; 00000274H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-436]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B41A6_protocol@c
	call	@__CheckForDebuggerJustMyCode@4

; 23   :     WORD wVersionRequested;
; 24   :     WSADATA WSAData;
; 25   : 	int status;
; 26   : 
; 27   :     wVersionRequested = MAKEWORD(1,1);

	mov	eax, 257				; 00000101H
	mov	WORD PTR _wVersionRequested$[ebp], ax

; 28   :     status = WSAStartup(wVersionRequested, &WSAData);

	lea	eax, DWORD PTR _WSAData$[ebp]
	push	eax
	movzx	ecx, WORD PTR _wVersionRequested$[ebp]
	push	ecx
	call	_WSAStartup@8
	mov	DWORD PTR _status$[ebp], eax

; 29   :     if (status != 0) {

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN3@socket_ini

; 30   :         printf("Windows Socket DLL Error\n");

	push	OFFSET ??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@
	call	_printf
	add	esp, 4

; 31   : 	    exit(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@socket_ini:

; 32   :     }
; 33   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@socket_ini
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 628				; 00000274H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@socket_ini:
	DD	1
	DD	$LN5@socket_ini
$LN5@socket_ini:
	DD	-420					; fffffe5cH
	DD	400					; 00000190H
	DD	$LN4@socket_ini
$LN4@socket_ini:
	DB	87					; 00000057H
	DB	83					; 00000053H
	DB	65					; 00000041H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_socket_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1780 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1460 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1392 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1397 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 646  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A2143F22_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 521  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A0B61CF9_time@h
	call	@__CheckForDebuggerJustMyCode@4

; 522  :             return _time64(_Time);

	mov	esi, esp
	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 523  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 498  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A0B61CF9_time@h
	call	@__CheckForDebuggerJustMyCode@4

; 499  :             return _localtime64(_Time);

	mov	esi, esp
	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 500  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
END
