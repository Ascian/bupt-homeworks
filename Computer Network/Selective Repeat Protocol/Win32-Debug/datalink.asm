; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

	TITLE	D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\Win32-Debug\datalink.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__32FB09EA_concurrencysal@h DB 01H
__92642135_sal@h DB 01H
__91763366_vadefs@h DB 01H
__53563FEE_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__CDDAF8CA_errno@h DB 01H
__1AB1F8E3_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__DDA4E3CF_stdarg@h DB 01H
__9158E1CF_lprintf@h DB 01H
__0B59982E_protocol@h DB 01H
__D5B142F3_datalink@h DB 01H
__42639B7B_datalink@c DB 01H
msvcjmc	ENDS
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0DD@FKAHOMIA@Designed?5by?5Chen?5Yu?0?5build?3?5May@ ; `string'
PUBLIC	??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ ; `string'
PUBLIC	??_C@_0N@IPGLALFM@Recv?5ACK?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0N@MBNEAINJ@Recv?5NAK?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ ; `string'
PUBLIC	??_C@_0BC@ODLGJAL@?9?9?9?9?5ACK?5timeout?6@	; `string'
PUBLIC	??_C@_0BC@LKBPFLLA@?9?9?9?9?5Buffer?5full?6@	; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_lprintf:PROC
EXTRN	_protocol_init:PROC
EXTRN	_wait_for_event:PROC
EXTRN	_enable_network_layer:PROC
EXTRN	_disable_network_layer:PROC
EXTRN	_get_packet:PROC
EXTRN	_put_packet:PROC
EXTRN	_recv_frame:PROC
EXTRN	_send_frame:PROC
EXTRN	_crc32:PROC
EXTRN	_start_timer:PROC
EXTRN	_stop_timer:PROC
EXTRN	_start_ack_timer:PROC
EXTRN	_stop_ack_timer:PROC
EXTRN	_dbg_event:PROC
EXTRN	_dbg_frame:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_ack_expected DB 01H DUP (?)
	ALIGN	4

_next_frame_to_send DB 01H DUP (?)
	ALIGN	4

_nbuffered DB	01H DUP (?)
	ALIGN	4

_out_buf DB	0b00H DUP (?)
_frame_expected DB 01H DUP (?)
	ALIGN	4

_in_buf	DB	0b00H DUP (?)
_arrived DB	0bH DUP (?)
	ALIGN	4

_phl_ready DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BC@LKBPFLLA@?9?9?9?9?5Buffer?5full?6@
CONST	SEGMENT
??_C@_0BC@LKBPFLLA@?9?9?9?9?5Buffer?5full?6@ DB '---- Buffer full', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ODLGJAL@?9?9?9?9?5ACK?5timeout?6@
CONST	SEGMENT
??_C@_0BC@ODLGJAL@?9?9?9?9?5ACK?5timeout?6@ DB '---- ACK timeout', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
CONST	SEGMENT
??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ DB '---- DATA %d tim'
	DB	'eout', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MBNEAINJ@Recv?5NAK?5?$CFd?6@
CONST	SEGMENT
??_C@_0N@MBNEAINJ@Recv?5NAK?5?$CFd?6@ DB 'Recv NAK %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IPGLALFM@Recv?5ACK?5?$CFd?6@
CONST	SEGMENT
??_C@_0N@IPGLALFM@Recv?5ACK?5?$CFd?6@ DB 'Recv ACK %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
CONST	SEGMENT
??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ DB '*'
	DB	'*** Receiver Error, Bad CRC Checksum', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FKAHOMIA@Designed?5by?5Chen?5Yu?0?5build?3?5May@
CONST	SEGMENT
??_C@_0DD@FKAHOMIA@Designed?5by?5Chen?5Yu?0?5build?3?5May@ DB 'Designed b'
	DB	'y Chen Yu, build: May 20 2022  17:46:38', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@ DB 'Send NAK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@ DB 'Send ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Send DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_too_far DB	0bH
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0492H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	025H
	DB	07cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	025H
	DB	090H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	013aH
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _main
_TEXT	SEGMENT
tv74 = -544						; size = 4
$T1 = -536						; size = 4
$T2 = -524						; size = 4
_i$ = -320						; size = 4
_len$ = -308						; size = 4
_f$ = -296						; size = 264
_arg$ = -24						; size = 4
_event$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 97   : 	int event;      //事件类型
; 98   : 	int arg;        //timer序号
; 99   : 	struct FRAME f; //物理层接收的帧
; 100  : 	int len = 0;    //物理层接收数据的长度

	mov	DWORD PTR _len$[ebp], 0

; 101  : 	int i;
; 102  : 	for (i = 0; i < NR_BUFS; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@main:
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jge	SHORT $LN3@main

; 103  : 		arrived[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 11			; 0000000bH
	jae	SHORT $LN31@main
	jmp	SHORT $LN32@main
$LN31@main:
	call	___report_rangecheckfailure
$LN32@main:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _arrived[ecx], 0

; 104  : 	}

	jmp	SHORT $LN2@main
$LN3@main:

; 105  : 
; 106  : 	protocol_init(argc, argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ecx
	call	_protocol_init
	add	esp, 8

; 107  : 	lprintf("Designed by Chen Yu, build: " __DATE__ "  "__TIME__"\n");

	push	OFFSET ??_C@_0DD@FKAHOMIA@Designed?5by?5Chen?5Yu?0?5build?3?5May@
	call	_lprintf
	add	esp, 4

; 108  : 
; 109  : 	disable_network_layer();

	call	_disable_network_layer
$LN5@main:

; 110  : 
; 111  : 	while (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN30@main

; 112  : 		event = wait_for_event(&arg);

	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_wait_for_event
	add	esp, 4
	mov	DWORD PTR _event$[ebp], eax

; 113  : 
; 114  : 		switch (event) {

	mov	eax, DWORD PTR _event$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 4
	ja	$LN7@main
	mov	ecx, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN35@main[ecx*4]
$LN13@main:

; 115  : 		case NETWORK_LAYER_READY:
; 116  : 			nbuffered++;

	mov	al, BYTE PTR _nbuffered
	add	al, 1
	mov	BYTE PTR _nbuffered, al

; 117  : 			get_packet(out_buf[next_frame_to_send % NR_BUFS]);

	movzx	eax, BYTE PTR _next_frame_to_send
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	shl	edx, 8
	add	edx, OFFSET _out_buf
	push	edx
	call	_get_packet
	add	esp, 4

; 118  : 			send_data_frame(next_frame_to_send);

	movzx	eax, BYTE PTR _next_frame_to_send
	push	eax
	call	_send_data_frame
	add	esp, 4

; 119  : 			inc(&next_frame_to_send);

	push	OFFSET _next_frame_to_send
	call	_inc
	add	esp, 4

; 120  : 			break;

	jmp	$LN7@main
$LN14@main:

; 121  : 
; 122  : 		case PHYSICAL_LAYER_READY:
; 123  : 			phl_ready = 1;

	mov	DWORD PTR _phl_ready, 1

; 124  : 			break;

	jmp	$LN7@main
$LN15@main:

; 125  : 
; 126  : 		case FRAME_RECEIVED:
; 127  : 			len = recv_frame((unsigned char *)&f, sizeof f);

	push	264					; 00000108H
	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_recv_frame
	add	esp, 8
	mov	DWORD PTR _len$[ebp], eax

; 128  : 			if (len < 5 || crc32((unsigned char *)&f, len) != 0) {

	cmp	DWORD PTR _len$[ebp], 5
	jl	SHORT $LN17@main
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_crc32
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@main
$LN17@main:

; 129  : 				dbg_event("**** Receiver Error, Bad CRC Checksum\n");

	push	OFFSET ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
	call	_dbg_event
	add	esp, 4

; 130  : 				if (len >= 5 ) {

	cmp	DWORD PTR _len$[ebp], 5
	jl	SHORT $LN18@main

; 131  : 					send_nak_frame(f.seq);

	movzx	eax, BYTE PTR _f$[ebp+2]
	push	eax
	call	_send_nak_frame
	add	esp, 4
$LN18@main:

; 132  : 				}
; 133  : 				break;

	jmp	$LN7@main
$LN16@main:

; 134  : 			}
; 135  : 			if (f.kind == FRAME_ACK)

	movzx	eax, BYTE PTR _f$[ebp]
	cmp	eax, 2
	jne	SHORT $LN19@main

; 136  : 				dbg_frame("Recv ACK %d\n", f.ack);

	movzx	eax, BYTE PTR _f$[ebp+1]
	push	eax
	push	OFFSET ??_C@_0N@IPGLALFM@Recv?5ACK?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8
$LN19@main:

; 137  : 			if (f.kind == FRAME_DATA) {

	movzx	eax, BYTE PTR _f$[ebp]
	cmp	eax, 1
	jne	$LN20@main

; 138  : 				dbg_frame("Recv DATA %d %d, ID %d\n", f.seq,

	movsx	eax, WORD PTR _f$[ebp+3]
	push	eax
	movzx	ecx, BYTE PTR _f$[ebp+1]
	push	ecx
	movzx	edx, BYTE PTR _f$[ebp+2]
	push	edx
	push	OFFSET ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	_dbg_frame
	add	esp, 16					; 00000010H

; 139  : 					  f.ack, *(short *)f.data);
; 140  : 				if (f.seq != frame_expected) {

	movzx	eax, BYTE PTR _f$[ebp+2]
	movzx	ecx, BYTE PTR _frame_expected
	cmp	eax, ecx
	je	SHORT $LN21@main

; 141  : 					start_ack_timer(ACK_TIMER);

	push	300					; 0000012cH
	call	_start_ack_timer
	add	esp, 4
$LN21@main:

; 142  : 				}
; 143  : 				if (between(f.seq,frame_expected, too_far) &&

	movzx	eax, BYTE PTR _too_far
	push	eax
	movzx	ecx, BYTE PTR _frame_expected
	push	ecx
	movzx	edx, BYTE PTR _f$[ebp+2]
	push	edx
	call	_between
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN20@main
	movzx	eax, BYTE PTR _f$[ebp+2]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	movzx	edx, BYTE PTR _arrived[edx]
	test	edx, edx
	jne	$LN20@main

; 144  : 				    arrived[f.seq % NR_BUFS] == 0){
; 145  : 					arrived[f.seq % NR_BUFS] = 1;

	movzx	eax, BYTE PTR _f$[ebp+2]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	mov	BYTE PTR _arrived[edx], 1

; 146  : 					memcpy(in_buf[f.seq % NR_BUFS], f.data, PKT_LEN);

	push	256					; 00000100H
	lea	eax, DWORD PTR _f$[ebp+3]
	push	eax
	movzx	eax, BYTE PTR _f$[ebp+2]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	shl	edx, 8
	add	edx, OFFSET _in_buf
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@main:

; 147  : 					while (arrived[frame_expected % NR_BUFS]) {

	movzx	eax, BYTE PTR _frame_expected
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	movzx	edx, BYTE PTR _arrived[edx]
	test	edx, edx
	je	$LN20@main

; 148  : 						put_packet(in_buf[frame_expected % NR_BUFS] ,len - 7);

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 7
	push	eax
	movzx	eax, BYTE PTR _frame_expected
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	shl	edx, 8
	add	edx, OFFSET _in_buf
	push	edx
	call	_put_packet
	add	esp, 8

; 149  : 						arrived[frame_expected % NR_BUFS] = 0;

	movzx	eax, BYTE PTR _frame_expected
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 11			; 0000000bH
	jae	SHORT $LN33@main
	jmp	SHORT $LN34@main
$LN33@main:
	call	___report_rangecheckfailure
$LN34@main:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _arrived[edx], 0

; 150  : 						inc(&frame_expected);

	push	OFFSET _frame_expected
	call	_inc
	add	esp, 4

; 151  : 						inc(&too_far);

	push	OFFSET _too_far
	call	_inc
	add	esp, 4

; 152  : 						start_ack_timer(ACK_TIMER);

	push	300					; 0000012cH
	call	_start_ack_timer
	add	esp, 4

; 153  : 					}

	jmp	$LN9@main
$LN20@main:

; 154  : 				}
; 155  : 			}
; 156  : 
; 157  : 			if (f.kind == FRAME_NAK) {

	movzx	eax, BYTE PTR _f$[ebp]
	cmp	eax, 3
	jne	SHORT $LN11@main

; 158  : 				dbg_frame("Recv NAK %d\n", f.ack);

	movzx	eax, BYTE PTR _f$[ebp+1]
	push	eax
	push	OFFSET ??_C@_0N@MBNEAINJ@Recv?5NAK?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 159  : 				if (between(f.ack,ack_expected,next_frame_to_send)) {

	movzx	eax, BYTE PTR _next_frame_to_send
	push	eax
	movzx	ecx, BYTE PTR _ack_expected
	push	ecx
	movzx	edx, BYTE PTR _f$[ebp+1]
	push	edx
	call	_between
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@main

; 160  : 					send_data_frame(f.ack);

	movzx	eax, BYTE PTR _f$[ebp+1]
	push	eax
	call	_send_data_frame
	add	esp, 4
$LN24@main:

; 161  : 				}
; 162  : 				break;

	jmp	$LN7@main
$LN11@main:

; 163  : 			}
; 164  : 
; 165  : 			while(between(f.ack,ack_expected,next_frame_to_send)) {

	movzx	eax, BYTE PTR _next_frame_to_send
	push	eax
	movzx	ecx, BYTE PTR _ack_expected
	push	ecx
	movzx	edx, BYTE PTR _f$[ebp+1]
	push	edx
	call	_between
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@main

; 166  : 				nbuffered--;

	mov	al, BYTE PTR _nbuffered
	sub	al, 1
	mov	BYTE PTR _nbuffered, al

; 167  : 				stop_timer(ack_expected % NR_BUFS);

	movzx	eax, BYTE PTR _ack_expected
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	push	edx
	call	_stop_timer
	add	esp, 4

; 168  : 				inc(&ack_expected);

	push	OFFSET _ack_expected
	call	_inc
	add	esp, 4

; 169  : 			}

	jmp	SHORT $LN11@main
$LN12@main:

; 170  : 			break;

	jmp	SHORT $LN7@main
$LN25@main:

; 171  : 
; 172  : 		case DATA_TIMEOUT:
; 173  : 			dbg_event("---- DATA %d timeout\n", arg);

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
	call	_dbg_event
	add	esp, 8

; 174  : 			send_data_frame(ack_expected);

	movzx	eax, BYTE PTR _ack_expected
	push	eax
	call	_send_data_frame
	add	esp, 4

; 175  : 			break;

	jmp	SHORT $LN7@main
$LN26@main:

; 176  : 
; 177  : 		case ACK_TIMEOUT:
; 178  : 			dbg_event("---- ACK timeout\n");

	push	OFFSET ??_C@_0BC@ODLGJAL@?9?9?9?9?5ACK?5timeout?6@
	call	_dbg_event
	add	esp, 4

; 179  : 			send_ack_frame();

	call	_send_ack_frame
$LN7@main:

; 180  : 		}
; 181  : 
; 182  : 		if (nbuffered < NR_BUFS && phl_ready)

	movzx	eax, BYTE PTR _nbuffered
	cmp	eax, 11					; 0000000bH
	jge	SHORT $LN27@main
	cmp	DWORD PTR _phl_ready, 0
	je	SHORT $LN27@main

; 183  : 			enable_network_layer();

	call	_enable_network_layer
	jmp	SHORT $LN28@main
$LN27@main:

; 184  : 		else {
; 185  : 			if (nbuffered >= NR_BUFS)

	movzx	eax, BYTE PTR _nbuffered
	cmp	eax, 11					; 0000000bH
	jl	SHORT $LN29@main

; 186  : 				dbg_event("---- Buffer full\n");

	push	OFFSET ??_C@_0BC@LKBPFLLA@?9?9?9?9?5Buffer?5full?6@
	call	_dbg_event
	add	esp, 4
$LN29@main:

; 187  : 			disable_network_layer();

	call	_disable_network_layer
$LN28@main:

; 188  : 		}	
; 189  : 	}

	jmp	$LN5@main
$LN30@main:

; 190  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN39@main
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 544				; 00000220H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN39@main:
	DD	2
	DD	$LN38@main
$LN38@main:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN36@main
	DD	-296					; fffffed8H
	DD	264					; 00000108H
	DD	$LN37@main
$LN37@main:
	DB	102					; 00000066H
	DB	0
$LN36@main:
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	0
	npad	2
$LN35@main:
	DD	$LN13@main
	DD	$LN14@main
	DD	$LN15@main
	DD	$LN25@main
	DD	$LN26@main
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _send_nak_frame
_TEXT	SEGMENT
_s$ = -272						; size = 264
__$ArrayPad$ = -4					; size = 4
_seq$ = 8						; size = 1
_send_nak_frame PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 84   : 	struct FRAME s;
; 85   : 
; 86   : 	s.kind = FRAME_NAK;

	mov	BYTE PTR _s$[ebp], 3

; 87   : 	s.ack = seq;

	mov	al, BYTE PTR _seq$[ebp]
	mov	BYTE PTR _s$[ebp+1], al

; 88   : 
; 89   : 	dbg_frame("Send NAK  %d\n", s.ack);

	movzx	eax, BYTE PTR _s$[ebp+1]
	push	eax
	push	OFFSET ??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 90   : 
; 91   : 	put_frame((unsigned char *)&s, 2);

	push	2
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_put_frame
	add	esp, 8

; 92   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@send_nak_f
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@send_nak_f:
	DD	1
	DD	$LN4@send_nak_f
$LN4@send_nak_f:
	DD	-272					; fffffef0H
	DD	264					; 00000108H
	DD	$LN3@send_nak_f
$LN3@send_nak_f:
	DB	115					; 00000073H
	DB	0
_send_nak_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _send_ack_frame
_TEXT	SEGMENT
_s$ = -272						; size = 264
__$ArrayPad$ = -4					; size = 4
_send_ack_frame PROC					; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 71   : 	struct FRAME s;
; 72   : 
; 73   : 	s.kind = FRAME_ACK;

	mov	BYTE PTR _s$[ebp], 2

; 74   : 	s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);

	movzx	eax, BYTE PTR _frame_expected
	add	eax, 21					; 00000015H
	cdq
	mov	ecx, 22					; 00000016H
	idiv	ecx
	mov	BYTE PTR _s$[ebp+1], dl

; 75   : 
; 76   : 	dbg_frame("Send ACK  %d\n", s.ack);

	movzx	eax, BYTE PTR _s$[ebp+1]
	push	eax
	push	OFFSET ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 77   : 
; 78   : 	put_frame((unsigned char *)&s, 2);

	push	2
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_put_frame
	add	esp, 8

; 79   : 	stop_ack_timer();

	call	_stop_ack_timer

; 80   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@send_ack_f
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@send_ack_f:
	DD	1
	DD	$LN4@send_ack_f
$LN4@send_ack_f:
	DD	-272					; fffffef0H
	DD	264					; 00000108H
	DD	$LN3@send_ack_f
$LN3@send_ack_f:
	DB	115					; 00000073H
	DB	0
_send_ack_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _send_data_frame
_TEXT	SEGMENT
_s$ = -272						; size = 264
__$ArrayPad$ = -4					; size = 4
_seq$ = 8						; size = 1
_send_data_frame PROC					; COMDAT

; 51   : static void send_data_frame(unsigned char seq) {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 52   : 	struct FRAME s;
; 53   : 	s.kind = FRAME_DATA;

	mov	BYTE PTR _s$[ebp], 1

; 54   : 	s.seq = seq;

	mov	al, BYTE PTR _seq$[ebp]
	mov	BYTE PTR _s$[ebp+2], al

; 55   : 	s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);

	movzx	eax, BYTE PTR _frame_expected
	add	eax, 21					; 00000015H
	cdq
	mov	ecx, 22					; 00000016H
	idiv	ecx
	mov	BYTE PTR _s$[ebp+1], dl

; 56   : 	memcpy(s.data, out_buf[seq % NR_BUFS], PKT_LEN);

	push	256					; 00000100H
	movzx	eax, BYTE PTR _seq$[ebp]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	shl	edx, 8
	add	edx, OFFSET _out_buf
	push	edx
	lea	edx, DWORD PTR _s$[ebp+3]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 57   : 
; 58   : 	dbg_frame("Send DATA %d %d, ID %d\n", s.seq, s.ack, *(short *)s.data);

	movsx	eax, WORD PTR _s$[ebp+3]
	push	eax
	movzx	ecx, BYTE PTR _s$[ebp+1]
	push	ecx
	movzx	edx, BYTE PTR _s$[ebp+2]
	push	edx
	push	OFFSET ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	_dbg_frame
	add	esp, 16					; 00000010H

; 59   : 
; 60   : 	put_frame((unsigned char *)&s, 3 + PKT_LEN);

	push	259					; 00000103H
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_put_frame
	add	esp, 8

; 61   : 	if (seq != next_frame_to_send) //重置重发帧和之后缓存帧的计时器

	movzx	eax, BYTE PTR _seq$[ebp]
	movzx	ecx, BYTE PTR _next_frame_to_send
	cmp	eax, ecx
	je	SHORT $LN5@send_data_

; 62   : 		for (; seq != next_frame_to_send; inc(&seq))

	jmp	SHORT $LN4@send_data_
$LN2@send_data_:
	lea	eax, DWORD PTR _seq$[ebp]
	push	eax
	call	_inc
	add	esp, 4
$LN4@send_data_:
	movzx	eax, BYTE PTR _seq$[ebp]
	movzx	ecx, BYTE PTR _next_frame_to_send
	cmp	eax, ecx
	je	SHORT $LN3@send_data_

; 63   : 			start_timer(seq % NR_BUFS, DATA_TIMER);

	push	1200					; 000004b0H
	movzx	eax, BYTE PTR _seq$[ebp]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	push	edx
	call	_start_timer
	add	esp, 8
	jmp	SHORT $LN2@send_data_
$LN3@send_data_:
	jmp	SHORT $LN6@send_data_
$LN5@send_data_:

; 64   : 	else
; 65   : 		start_timer(seq % NR_BUFS, DATA_TIMER);

	push	1200					; 000004b0H
	movzx	eax, BYTE PTR _seq$[ebp]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	push	edx
	call	_start_timer
	add	esp, 8
$LN6@send_data_:

; 66   : 	stop_ack_timer();

	call	_stop_ack_timer

; 67   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@send_data_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@send_data_:
	DD	1
	DD	$LN9@send_data_
$LN9@send_data_:
	DD	-272					; fffffef0H
	DD	264					; 00000108H
	DD	$LN8@send_data_
$LN8@send_data_:
	DB	115					; 00000073H
	DB	0
_send_data_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _put_frame
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_len$ = 12						; size = 4
_put_frame PROC						; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 46   : 	*(unsigned int *)(frame + len) = crc32(frame, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_crc32
	add	esp, 8
	mov	edx, DWORD PTR _frame$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], eax

; 47   : 	send_frame(frame, len + 4);

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_send_frame
	add	esp, 8

; 48   : 	phl_ready = 0;

	mov	DWORD PTR _phl_ready, 0

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _between
_TEXT	SEGMENT
tv82 = -196						; size = 4
_seq$ = 8						; size = 1
_begin$ = 12						; size = 1
_end$ = 16						; size = 1
_between PROC						; COMDAT

; 38   : static int between(unsigned char seq, unsigned char begin, unsigned char end) {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 39   : 	return ((begin <= seq) && (seq < end)) ||

	movzx	eax, BYTE PTR _begin$[ebp]
	movzx	ecx, BYTE PTR _seq$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN3@between
	movzx	edx, BYTE PTR _seq$[ebp]
	movzx	eax, BYTE PTR _end$[ebp]
	cmp	edx, eax
	jl	SHORT $LN5@between
$LN3@between:
	movzx	ecx, BYTE PTR _end$[ebp]
	movzx	edx, BYTE PTR _begin$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN4@between
	movzx	eax, BYTE PTR _begin$[ebp]
	movzx	ecx, BYTE PTR _seq$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN5@between
$LN4@between:
	movzx	edx, BYTE PTR _seq$[ebp]
	movzx	eax, BYTE PTR _end$[ebp]
	cmp	edx, eax
	jge	SHORT $LN6@between
	movzx	ecx, BYTE PTR _end$[ebp]
	movzx	edx, BYTE PTR _begin$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN5@between
$LN6@between:
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN7@between
$LN5@between:
	mov	DWORD PTR tv82[ebp], 1
$LN7@between:
	mov	eax, DWORD PTR tv82[ebp]

; 40   : 	       ((end < begin) && (begin <= seq)) ||
; 41   : 	       ((seq < end) && (end < begin));
; 42   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_between ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\datalink.c
;	COMDAT _inc
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_inc	PROC						; COMDAT

; 34   : static void inc(unsigned char* seq) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __42639B7B_datalink@c
	call	@__CheckForDebuggerJustMyCode@4

; 35   : 	*seq = ((*seq) + 1) % (MAX_SEQ + 1);

	mov	eax, DWORD PTR _seq$[ebp]
	movzx	eax, BYTE PTR [eax]
	add	eax, 1
	cdq
	mov	ecx, 22					; 00000016H
	idiv	ecx
	mov	eax, DWORD PTR _seq$[ebp]
	mov	BYTE PTR [eax], dl

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_inc	ENDP
_TEXT	ENDS
END
