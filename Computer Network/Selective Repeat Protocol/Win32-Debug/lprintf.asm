; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

	TITLE	D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\Win32-Debug\lprintf.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_log_file
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef@		; `string'
_BSS	SEGMENT
_log_file DD	01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__D0DFFAC6_winpackagefamily@h DB 01H
__D0D0F397_winapifamily@h DB 01H
__94A3FDDD_sdkddkver@h DB 01H
__32FB09EA_concurrencysal@h DB 01H
__92642135_sal@h DB 01H
__91763366_vadefs@h DB 01H
__53563FEE_vcruntime@h DB 01H
__3A5FEF39_excpt@h DB 01H
__DDA4E3CF_stdarg@h DB 01H
__1C9F390F_specstrings_undef@h DB 01H
__36A21E95_specstrings_strict@h DB 01H
__452FE810_sdv_driverspecs@h DB 01H
__30F344B3_driverspecs@h DB 01H
__BD886E18_specstrings@h DB 01H
__6569C2CA_corecrt@h DB 01H
__5DB64B66_corecrt_wctype@h DB 01H
__B2D2BA86_ctype@h DB 01H
__BF9C347F_kernelspecs@h DB 01H
__79C7FC57_basetsd@h DB 01H
__CDDAF8CA_errno@h DB 01H
__1AB1F8E3_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__DF4F952E_pshpack4@h DB 01H
__7FCD0577_poppack@h DB 01H
__DBC2E99C_pshpack2@h DB 01H
__D6556C4A_pshpack8@h DB 01H
__D98457C5_pshpack1@h DB 01H
__614C4572_apiset@h DB 01H
__8500295D_ktmtypes@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__156BD51A_minwindef@h DB 01H
__F9B9A8F7_windef@h DB 01H
__BD2C4590_apisetcconv@h DB 01H
__18251742_minwinbase@h DB 01H
__23611203_apiquery2@h DB 01H
__C914CD48_processenv@h DB 01H
__996311FD_fileapi@h DB 01H
__41AEF397_fileapifromapp@h DB 01H
__65579FF3_debugapi@h DB 01H
__476FCB5A_utilapiset@h DB 01H
__089D2E42_handleapi@h DB 01H
__B16F04F5_errhandlingapi@h DB 01H
__81CCB02F_fibersapi@h DB 01H
__A9B4C5F0_namedpipeapi@h DB 01H
__C209F2C8_profileapi@h DB 01H
__34C22DC8_heapapi@h DB 01H
__8A238485_ioapiset@h DB 01H
__4826BA69_synchapi@h DB 01H
__6A31599C_interlockedapi@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__7BB37CFA_sysinfoapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__6D078C0D_enclaveapi@h DB 01H
__3663CE50_threadpoollegacyapiset@h DB 01H
__E16717D9_threadpoolapiset@h DB 01H
__4A6035CC_jobapi@h DB 01H
__62EEB553_jobapi2@h DB 01H
__9F22E7EF_wow64apiset@h DB 01H
__E86B4A9A_libloaderapi@h DB 01H
__EB536E54_securitybaseapi@h DB 01H
__E915C287_namespaceapi@h DB 01H
__C66F44F2_systemtopologyapi@h DB 01H
__B6175B28_processtopologyapi@h DB 01H
__9E4AD838_securityappcontainer@h DB 01H
__F599FDAE_realtimeapiset@h DB 01H
__D4435474_winerror@h DB 01H
__F94F31E6_timezoneapi@h DB 01H
__B3ED30D4_winbase@h DB 01H
__E9F7D11F_wingdi@h DB 01H
__AC21C382_tvout@h DB 01H
__DB057BA3_winuser@h DB 01H
__A1BAD304_datetimeapi@h DB 01H
__30E2BD27_winnls@h DB 01H
__B7FF4B97_stringapiset@h DB 01H
__66C87297_wincontypes@h DB 01H
__1317218F_consoleapi@h DB 01H
__8D62D26D_consoleapi2@h DB 01H
__8CA0B85A_consoleapi3@h DB 01H
__CE39E65B_wincon@h DB 01H
__F6801ACC_verrsrc@h DB 01H
__1CB844D9_winver@h DB 01H
__D0CFA71C_reason@h DB 01H
__F3D58382_winreg@h DB 01H
__34C28572_wnnc@h DB 01H
__0617DE59_winnetwk@h DB 01H
__93AC9EF8_cderr@h DB 01H
__3AE29FFA_dde@h DB 01H
__48250249_ddeml@h DB 01H
__4605C6DD_dlgs@h DB 01H
__C826BBA2_lzexpand@h DB 01H
__B8DFB118_mmsyscom@h DB 01H
__EDC2A662_mciapi@h DB 01H
__87B17D5B_mmiscapi@h DB 01H
__0C4862FC_mmiscapi2@h DB 01H
__83F5D08C_playsoundapi@h DB 01H
__CA3F1D44_mmeapi@h DB 01H
__BD2270BE_timeapi@h DB 01H
__397CAA2F_joystickapi@h DB 01H
__05A21AEE_mmsystem@h DB 01H
__6E1DF0B6_nb30@h DB 01H
__75098885_rpcdcep@h DB 01H
__D8AC8DD5_rpcdce@h DB 01H
__2F1118EF_rpcnsi@h DB 01H
__0DE10DFC_rpcnterr@h DB 01H
__4497164E_rpcasync@h DB 01H
__06CA6763_rpc@h DB 01H
__C32EC2F2_shellapi@h DB 01H
__B289ECB8_winperf@h DB 01H
__07EA6B7C_inaddr@h DB 01H
__9ED0251E_winsock@h DB 01H
__FD938996_bcrypt@h DB 01H
__4E32BFB9_ncrypt@h DB 01H
__815AA9AD_dpapi@h DB 01H
__0B2E95FF_wincrypt@h DB 01H
__288F6C52_winefs@h DB 01H
__B3F2ECA2_rpcnsip@h DB 01H
__AFB43543_rpcsal@h DB 01H
__16A21838_rpcndr@h DB 01H
__5314805F_wtypesbase@h DB 01H
__6EEE3703_wtypes@h DB 01H
__A7113148_winioctl@h DB 01H
__C595A37C_winsmcrd@h DB 01H
__42C56FB7_winscard@h DB 01H
__C4703BCA_prsht@h DB 01H
__D4D77F19_winspool@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__570D733F_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__B47185B4_unknwnbase@h DB 01H
__B64C33F8_objidlbase@h DB 01H
__EA871F04_cguid@h DB 01H
__C78732AB_combaseapi@h DB 01H
__744BF5DA_unknwn@h DB 01H
__66C491E7_objidl@h DB 01H
__A217658B_oaidl@h DB 01H
__8485F416_propidlbase@h DB 01H
__65805CE1_coml2api@h DB 01H
__C7AD586F_oleidl@h DB 01H
__CBE55221_servprov@h DB 01H
__5B1E268A_msxml@h DB 01H
__1B3D3678_urlmon@h DB 01H
__EC5BC72C_propidl@h DB 01H
__0DD0E8F8_objbase@h DB 01H
__6DA674A0_oleauto@h DB 01H
__F7931962_ole2@h DB 01H
__870E9EB1_commdlg@h DB 01H
__A118E6DC_stralign@h DB 01H
__8B10FA9F_winsvc@h DB 01H
__BEDBF511_mcx@h DB 01H
__D3BCC989_ime_cmodes@h DB 01H
__B1694579_imm@h DB 01H
__4D4D253D_windows@h DB 01H
__64F617E8_types@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__9158E1CF_lprintf@h DB 01H
__068A3847_lprintf@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_lprintf
PUBLIC	___v_lprintf
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@		; `string'
PUBLIC	??_C@_0BB@GHIALFFI@0000000000000000@		; `string'
PUBLIC	??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_05MAGFAFAN@?$CInil?$CJ@			; `string'
PUBLIC	??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@	; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ@			; `string'
PUBLIC	??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02MDDDDAID@0x@				; `string'
PUBLIC	??_C@_02FGLHBECB@0X@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	__real@0000000000000000
EXTRN	__imp___errno:PROC
EXTRN	_memmove:PROC
EXTRN	_strchr:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__strerror:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_get_ms:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLHBECB@0X@
CONST	SEGMENT
??_C@_02FGLHBECB@0X@ DB '0X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x@
CONST	SEGMENT
??_C@_02MDDDDAID@0x@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@ DB '(%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ@ DB '(null)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@
CONST	SEGMENT
??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@ DB '%%%zd.%zd%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAGFAFAN@?$CInil?$CJ@
CONST	SEGMENT
??_C@_05MAGFAFAN@?$CInil?$CJ@ DB '(nil)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB '                '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHIALFFI@0000000000000000@
CONST	SEGMENT
??_C@_0BB@GHIALFFI@0000000000000000@ DB '0000000000000000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
CONST	SEGMENT
??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@ DB '%03d.%03d ', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?sol@?1??output@@9@9 DD 01H				; `output'::`2'::sol
?char_set@?1??output_memory_block@@9@9 DD FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@ ; `output_memory_block'::`2'::char_set
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0255H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0253H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0319H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	01faH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	05bbH
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _output_memory_block
_TEXT	SEGMENT
_len$ = -288						; size = 4
_s$ = -276						; size = 4
_str$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_ptr$ = 8						; size = 4
_n$ = 12						; size = 4
_width$ = 16						; size = 4
_precision$ = 20					; size = 4
_flag$ = 24						; size = 4
_pad$ = 28						; size = 4
_output_memory_block PROC				; COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 323  :     static const char *char_set = "0123456789abcdef";
; 324  :     char str[256], *s;
; 325  :     size_t len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 326  :     
; 327  :     if (ptr == NULL) 

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $LN4@output_mem

; 328  :         return output_string("(null)", 6, 0, width, precision, flag, pad, ' ');

	push	32					; 00000020H
	movzx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	0
	push	6
	push	OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ@
	call	_output_string
	add	esp, 32					; 00000020H
	jmp	$LN1@output_mem
$LN4@output_mem:

; 329  : 
; 330  :     s = str; 

	lea	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 331  :     if (flag & F_HASH) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 4
	je	SHORT $LN5@output_mem

; 332  :         s += sprintf(s, "(%d) ", n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN5@output_mem:

; 333  : 
; 334  :     if (n > (sizeof(str) - 32) / 3) 

	cmp	DWORD PTR _n$[ebp], 74			; 0000004aH
	jbe	SHORT $LN2@output_mem

; 335  :         width = precision = 0;

	mov	DWORD PTR _precision$[ebp], 0
	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN2@output_mem:

; 336  :         
; 337  :     while (n > 0) {

	cmp	DWORD PTR _n$[ebp], 0
	jle	$LN3@output_mem

; 338  :         if (pad != '0' && *ptr < 0x10) 

	cmp	DWORD PTR _pad$[ebp], 48		; 00000030H
	je	SHORT $LN7@output_mem
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN7@output_mem

; 339  :             *s++ = char_set[*ptr];

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR ?char_set@?1??output_memory_block@@9@9
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
	jmp	SHORT $LN8@output_mem
$LN7@output_mem:

; 340  :         else {
; 341  :             *s++ = char_set[*ptr / 16];

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [eax]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR ?char_set@?1??output_memory_block@@9@9
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 342  :             *s++ = char_set[*ptr % 16];

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, -2147483633			; 8000000fH
	jns	SHORT $LN16@output_mem
	dec	ecx
	or	ecx, -16				; fffffff0H
	inc	ecx
$LN16@output_mem:
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR ?char_set@?1??output_memory_block@@9@9
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN8@output_mem:

; 343  :         }
; 344  : 
; 345  :         n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 346  :         if (n > 0)

	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN9@output_mem

; 347  :             *s++ = ' ';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN9@output_mem:

; 348  : 
; 349  :         ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 350  :         if (s - str > sizeof(str) - 4) {

	mov	eax, DWORD PTR _s$[ebp]
	lea	ecx, DWORD PTR _str$[ebp]
	sub	eax, ecx
	cmp	eax, 252				; 000000fcH
	jbe	SHORT $LN10@output_mem

; 351  :             len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	push	32					; 00000020H
	movzx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR _str$[ebp]
	sub	ecx, edx
	push	ecx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_output_string
	add	esp, 32					; 00000020H
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 352  :             s = str;

	lea	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN10@output_mem:

; 353  :         }
; 354  :     }

	jmp	$LN2@output_mem
$LN3@output_mem:

; 355  : 
; 356  :     if (s != str) 

	lea	eax, DWORD PTR _str$[ebp]
	cmp	DWORD PTR _s$[ebp], eax
	je	SHORT $LN11@output_mem

; 357  :         len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	push	32					; 00000020H
	movzx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR _str$[ebp]
	sub	ecx, edx
	push	ecx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_output_string
	add	esp, 32					; 00000020H
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN11@output_mem:

; 358  : 
; 359  :     return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@output_mem:

; 360  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@output_mem
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 484				; 000001e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@output_mem:
	DD	1
	DD	$LN14@output_mem
$LN14@output_mem:
	DD	-264					; fffffef8H
	DD	256					; 00000100H
	DD	$LN13@output_mem
$LN13@output_mem:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_output_memory_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _output_double
_TEXT	SEGMENT
tv94 = -584						; size = 4
_sz$ = -384						; size = 4
_prefix_len$ = -372					; size = 4
_p$ = -360						; size = 4
_s$ = -348						; size = 4
_buf$ = -336						; size = 256
_fmt$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_d$ = 8							; size = 8
_type$ = 16						; size = 1
_width$ = 20						; size = 4
_precision$ = 24					; size = 4
_flag$ = 28						; size = 4
_pad$ = 32						; size = 4
_output_double PROC					; COMDAT

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-392]
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 271  :     char fmt[64], buf[256], *s, *p;
; 272  :     size_t prefix_len = 0, sz;

	mov	DWORD PTR _prefix_len$[ebp], 0

; 273  : 
; 274  :     if (width == 0) 

	cmp	DWORD PTR _width$[ebp], 0
	jne	SHORT $LN8@output_dou

; 275  :         width = 1;

	mov	DWORD PTR _width$[ebp], 1
$LN8@output_dou:

; 276  :     if (!(flag & F_DOT)) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 64					; 00000040H
	jne	SHORT $LN9@output_dou

; 277  :         precision = 6;

	mov	DWORD PTR _precision$[ebp], 6
$LN9@output_dou:

; 278  :     if (d < 0.0) 

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _d$[ebp]
	jbe	SHORT $LN10@output_dou

; 279  :         prefix_len = 1;

	mov	DWORD PTR _prefix_len$[ebp], 1
$LN10@output_dou:

; 280  : 
; 281  :     s = buf + 1;

	lea	eax, DWORD PTR _buf$[ebp+1]
	mov	DWORD PTR _s$[ebp], eax

; 282  :     
; 283  :     sprintf(fmt, "%%%zd.%zd%c", width, precision, type);

	movsx	eax, BYTE PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@
	lea	eax, DWORD PTR _fmt$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 284  :     sprintf(s, fmt, d);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 285  :     
; 286  :     for (p = s; *p == ' '; p++);

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@output_dou
$LN2@output_dou:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$LN4@output_dou:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@output_dou
	jmp	SHORT $LN2@output_dou
$LN3@output_dou:
$LN5@output_dou:

; 287  : 
; 288  :     for (;;) {
; 289  :         *s = *p;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 290  :         if (*p == '\0')

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@output_dou

; 291  :             break;

	jmp	SHORT $LN6@output_dou
$LN11@output_dou:

; 292  :         s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 293  :         p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 294  :     } 

	jmp	SHORT $LN5@output_dou
$LN6@output_dou:

; 295  :     s = buf + 1;

	lea	eax, DWORD PTR _buf$[ebp+1]
	mov	DWORD PTR _s$[ebp], eax

; 296  :     sz = strlen(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sz$[ebp], eax

; 297  : 
; 298  :     if ((flag & (F_PLUS | F_SPACE)) && d >= 0) {

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 48					; 00000030H
	je	SHORT $LN12@output_dou
	movsd	xmm0, QWORD PTR _d$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN12@output_dou

; 299  :         prefix_len = 1;

	mov	DWORD PTR _prefix_len$[ebp], 1

; 300  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN16@output_dou
	mov	DWORD PTR tv94[ebp], 43			; 0000002bH
	jmp	SHORT $LN17@output_dou
$LN16@output_dou:
	mov	DWORD PTR tv94[ebp], 32			; 00000020H
$LN17@output_dou:
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR tv94[ebp]
	mov	BYTE PTR [edx], al

; 301  :         sz++;

	mov	eax, DWORD PTR _sz$[ebp]
	add	eax, 1
	mov	DWORD PTR _sz$[ebp], eax
$LN12@output_dou:

; 302  :     }
; 303  :     
; 304  :     if ((flag & F_HASH) && type == 'f' && strchr(s, '.') == NULL) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 4
	je	SHORT $LN13@output_dou
	movsx	eax, BYTE PTR _type$[ebp]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN13@output_dou
	push	46					; 0000002eH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@output_dou

; 305  :         s[sz++] = '.';

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _sz$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _sz$[ebp]
	add	ecx, 1
	mov	DWORD PTR _sz$[ebp], ecx
$LN13@output_dou:

; 306  :     
; 307  :     if (width < sz) 

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _sz$[ebp]
	jae	SHORT $LN14@output_dou

; 308  :         width = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN14@output_dou:

; 309  :     flag &= ~F_DOT;

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _flag$[ebp], eax

; 310  :    
; 311  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	push	48					; 00000030H
	movzx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix_len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_output_string
	add	esp, 32					; 00000020H

; 312  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@output_dou
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 584				; 00000248H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN21@output_dou:
	DD	2
	DD	$LN20@output_dou
$LN20@output_dou:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN18@output_dou
	DD	-336					; fffffeb0H
	DD	256					; 00000100H
	DD	$LN19@output_dou
$LN19@output_dou:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN18@output_dou:
	DB	102					; 00000066H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
_output_double ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _output_integer
_TEXT	SEGMENT
tv159 = -396						; size = 4
_is_negative$ = -196					; size = 4
_n$ = -184						; size = 4
_prefix_len$ = -172					; size = 4
_sz$ = -160						; size = 4
_s$ = -148						; size = 4
_buf$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_num$ = 8						; size = 8
_opt_long$ = 16						; size = 4
_type$ = 20						; size = 1
_width$ = 24						; size = 4
_precision$ = 28					; size = 4
_flag$ = 32						; size = 4
_base$ = 36						; size = 4
_prefix$ = 40						; size = 4
_pad$ = 44						; size = 1
_output_integer PROC					; COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 203  :     char buf[128], *s;
; 204  :     size_t sz, prefix_len, n;
; 205  :     bool is_negative;
; 206  : 
; 207  :     if (precision > width) 

	mov	eax, DWORD PTR _precision$[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jbe	SHORT $LN2@output_int

; 208  :         width = precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN2@output_int:

; 209  :     
; 210  :     s = buf + 1;

	lea	eax, DWORD PTR _buf$[ebp+1]
	mov	DWORD PTR _s$[ebp], eax

; 211  :     if (type == 'p') {

	movsx	eax, BYTE PTR _type$[ebp]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN3@output_int

; 212  :         if (num == 0) {

	mov	eax, DWORD PTR _num$[ebp]
	or	eax, DWORD PTR _num$[ebp+4]
	jne	SHORT $LN3@output_int

; 213  :             s = "(nil)";

	mov	DWORD PTR _s$[ebp], OFFSET ??_C@_05MAGFAFAN@?$CInil?$CJ@

; 214  :             return output_string(s, strlen(s), 0, width, precision, flag, ' ', ' ');

	push	32					; 00000020H
	push	32					; 00000020H
	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_output_string
	add	esp, 32					; 00000020H
	jmp	$LN1@output_int
$LN3@output_int:

; 215  :         } 
; 216  :     } 
; 217  : 
; 218  :     strcpy(s, prefix);

	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 219  :     sz = strlen(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sz$[ebp], eax

; 220  :     prefix_len = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _prefix_len$[ebp], eax

; 221  :      
; 222  :     is_negative = false;

	mov	DWORD PTR _is_negative$[ebp], 0

; 223  :     if (flag & F_SIGN) {

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $LN5@output_int

; 224  :         if ((signed __int64)num < 0) {

	cmp	DWORD PTR _num$[ebp+4], 0
	jg	SHORT $LN5@output_int
	jl	SHORT $LN26@output_int
	cmp	DWORD PTR _num$[ebp], 0
	jae	SHORT $LN5@output_int
$LN26@output_int:

; 225  :             num = -(signed __int64)num;

	mov	eax, DWORD PTR _num$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _num$[ebp+4]
	adc	ecx, 0
	neg	ecx
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], ecx

; 226  :             is_negative = true;

	mov	DWORD PTR _is_negative$[ebp], 1
$LN5@output_int:

; 227  :         }
; 228  :     } 
; 229  :     
; 230  :     if (opt_long == 1)

	cmp	DWORD PTR _opt_long$[ebp], 1
	jne	SHORT $LN7@output_int

; 231  :         num &= (unsigned long)-1;

	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _num$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], ecx
	jmp	SHORT $LN8@output_int
$LN7@output_int:

; 232  :     else if (opt_long == 0)

	cmp	DWORD PTR _opt_long$[ebp], 0
	jne	SHORT $LN9@output_int

; 233  :         num &= (unsigned int)-1;

	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _num$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], ecx
	jmp	SHORT $LN8@output_int
$LN9@output_int:

; 234  :     else if (opt_long == -1) 

	cmp	DWORD PTR _opt_long$[ebp], -1
	jne	SHORT $LN11@output_int

; 235  :         num &= 0xffff;

	mov	eax, DWORD PTR _num$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _num$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], ecx
	jmp	SHORT $LN8@output_int
$LN11@output_int:

; 236  :     else if (opt_long == -2) 

	cmp	DWORD PTR _opt_long$[ebp], -2		; fffffffeH
	jne	SHORT $LN8@output_int

; 237  :         num &= 0xff;

	mov	eax, DWORD PTR _num$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _num$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], ecx
$LN8@output_int:

; 238  : 
; 239  :     n = int64_str(s + sz, sizeof(buf) - sz - 1, num, base, flag & F_UPCASE);

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 2
	push	eax
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _num$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, 128				; 00000080H
	sub	ecx, DWORD PTR _sz$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_int64_str
	add	esp, 24					; 00000018H
	mov	DWORD PTR _n$[ebp], eax

; 240  : 
; 241  :     /* When 0 is printed with an explicit precision 0, the output is empty. */
; 242  :     if ((flag & F_DOT) && n == 1 && s[sz] == '0') {

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN14@output_int
	cmp	DWORD PTR _n$[ebp], 1
	jne	SHORT $LN14@output_int
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _sz$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN14@output_int

; 243  :         if (precision == 0 || prefix_len > 0) 

	cmp	DWORD PTR _precision$[ebp], 0
	je	SHORT $LN17@output_int
	cmp	DWORD PTR _prefix_len$[ebp], 0
	jbe	SHORT $LN16@output_int
$LN17@output_int:

; 244  :             sz = 0;

	mov	DWORD PTR _sz$[ebp], 0
$LN16@output_int:

; 245  :         prefix_len = 0;

	mov	DWORD PTR _prefix_len$[ebp], 0

; 246  :     } else 

	jmp	SHORT $LN15@output_int
$LN14@output_int:

; 247  :         sz += n;

	mov	eax, DWORD PTR _sz$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _sz$[ebp], eax
$LN15@output_int:

; 248  :     
; 249  :     if (is_negative) {

	cmp	DWORD PTR _is_negative$[ebp], 0
	je	SHORT $LN18@output_int

; 250  :         prefix_len = 1;

	mov	DWORD PTR _prefix_len$[ebp], 1

; 251  :         *(--s) = '-';

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH

; 252  :         sz++;

	mov	eax, DWORD PTR _sz$[ebp]
	add	eax, 1
	mov	DWORD PTR _sz$[ebp], eax
	jmp	SHORT $LN19@output_int
$LN18@output_int:

; 253  :     } else if ((flag & F_SIGN) && (flag & (F_PLUS | F_SPACE))) {

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $LN19@output_int
	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 48					; 00000030H
	je	SHORT $LN19@output_int

; 254  :         prefix_len = 1;

	mov	DWORD PTR _prefix_len$[ebp], 1

; 255  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN24@output_int
	mov	DWORD PTR tv159[ebp], 43		; 0000002bH
	jmp	SHORT $LN25@output_int
$LN24@output_int:
	mov	DWORD PTR tv159[ebp], 32		; 00000020H
$LN25@output_int:
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR tv159[ebp]
	mov	BYTE PTR [edx], al

; 256  :         sz++;

	mov	eax, DWORD PTR _sz$[ebp]
	add	eax, 1
	mov	DWORD PTR _sz$[ebp], eax
$LN19@output_int:

; 257  :     } 
; 258  : 
; 259  :     if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN21@output_int

; 260  :         pad = ' ';

	mov	BYTE PTR _pad$[ebp], 32			; 00000020H
$LN21@output_int:

; 261  : 
; 262  :     if (sz - prefix_len > precision)

	mov	eax, DWORD PTR _sz$[ebp]
	sub	eax, DWORD PTR _prefix_len$[ebp]
	cmp	eax, DWORD PTR _precision$[ebp]
	jbe	SHORT $LN22@output_int

; 263  :         precision = sz - prefix_len;

	mov	eax, DWORD PTR _sz$[ebp]
	sub	eax, DWORD PTR _prefix_len$[ebp]
	mov	DWORD PTR _precision$[ebp], eax
$LN22@output_int:

; 264  : 
; 265  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	push	48					; 00000030H
	movzx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix_len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_output_string
	add	esp, 32					; 00000020H
$LN1@output_int:

; 266  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@output_int
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 396				; 0000018cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@output_int:
	DD	1
	DD	$LN28@output_int
$LN28@output_int:
	DD	-136					; ffffff78H
	DD	128					; 00000080H
	DD	$LN27@output_int
$LN27@output_int:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_output_integer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _output_string
_TEXT	SEGMENT
_len$ = -20						; size = 4
_prefix$ = -8						; size = 4
_str$ = 8						; size = 4
_size$ = 12						; size = 4
_prefix_len$ = 16					; size = 4
_width$ = 20						; size = 4
_precision$ = 24					; size = 4
_flag$ = 28						; size = 4
_pad$ = 32						; size = 1
_precision_pad$ = 36					; size = 1
_output_string PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 130  :     const char *prefix;
; 131  :     size_t len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 132  :  
; 133  :     if (width == 0 && precision == 0) {

	cmp	DWORD PTR _width$[ebp], 0
	jne	SHORT $LN2@output_str
	cmp	DWORD PTR _precision$[ebp], 0
	jne	SHORT $LN2@output_str

; 134  :         output(str, size); 

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_output
	add	esp, 8

; 135  :         return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	$LN1@output_str
$LN2@output_str:

; 136  :     }
; 137  :     
; 138  :     prefix = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _prefix$[ebp], eax

; 139  :     
; 140  :     if (prefix_len) {

	cmp	DWORD PTR _prefix_len$[ebp], 0
	je	SHORT $LN3@output_str

; 141  :         str += prefix_len;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _prefix_len$[ebp]
	mov	DWORD PTR _str$[ebp], eax

; 142  :         size -= prefix_len;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _prefix_len$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 143  :         width -= prefix_len;

	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, DWORD PTR _prefix_len$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN3@output_str:

; 144  :     }
; 145  :      
; 146  :     /* These are the cases for 1234 or "1234" respectively:
; 147  :         %.6u -> "001234"
; 148  :         %6u  -> "  1234"
; 149  :         %06u -> "001234"
; 150  :         %-6u -> "1234  "
; 151  :         %.6s -> "1234"
; 152  :         %6s  -> "  1234"
; 153  :         %06s -> "  1234"
; 154  :         %-6s -> "1234  "
; 155  :         %6.5u -> " 01234"
; 156  :         %6.5s -> "  1234"
; 157  :         In this code, for %6.5s, 6 is width, 5 is precision.
; 158  :         flag_dot means there was a '.' and precision is set.
; 159  :         flag_left means there was a '-'.
; 160  :         sz is 4 (strlen("1234")).
; 161  :         pad will be '0' for %06u, ' ' otherwise.
; 162  :         precision_pad is '0' for %u, ' ' for %s.
; 163  :     */
; 164  :     
; 165  :     if ((flag & F_DOT) && width == 0) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN4@output_str
	cmp	DWORD PTR _width$[ebp], 0
	jne	SHORT $LN4@output_str

; 166  :         width = precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN4@output_str:

; 167  :     
; 168  :     if (!(flag & F_DOT)) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 64					; 00000040H
	jne	SHORT $LN5@output_str

; 169  :         precision = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _precision$[ebp], eax
$LN5@output_str:

; 170  : 
; 171  :     /* do left-side padding with spaces */
; 172  :     if (!(flag & F_LEFT) && pad == ' ') 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 8
	jne	SHORT $LN6@output_str
	movsx	eax, BYTE PTR _pad$[ebp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@output_str

; 173  :         len += write_pad(width - precision, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, DWORD PTR _precision$[ebp]
	push	eax
	call	_write_pad
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN6@output_str:

; 174  :     
; 175  :     if (prefix_len) {

	cmp	DWORD PTR _prefix_len$[ebp], 0
	je	SHORT $LN7@output_str

; 176  :         output(prefix, prefix_len);

	mov	eax, DWORD PTR _prefix_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	call	_output
	add	esp, 8

; 177  :         len += prefix_len;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, DWORD PTR _prefix_len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN7@output_str:

; 178  :     }
; 179  : 
; 180  :     /* do left-side padding with '0' */
; 181  :     if (!(flag & F_LEFT) && pad == '0') 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 8
	jne	SHORT $LN8@output_str
	movsx	eax, BYTE PTR _pad$[ebp]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN8@output_str

; 182  :         len += write_pad(width - precision, '0');

	push	48					; 00000030H
	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, DWORD PTR _precision$[ebp]
	push	eax
	call	_write_pad
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN8@output_str:

; 183  :     
; 184  :     /* do precision padding */
; 185  :     len += write_pad(precision - size, precision_pad);

	movsx	eax, BYTE PTR _precision_pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	sub	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	_write_pad
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 186  :     
; 187  :     /* write actual string */
; 188  :     output(str, size); 

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_output
	add	esp, 8

; 189  :     len += size;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 190  : 
; 191  :     /* do right-side padding */
; 192  :     if (flag & F_LEFT) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 8
	je	SHORT $LN9@output_str

; 193  :         len += write_pad(width - precision, pad);

	movsx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	sub	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	call	_write_pad
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN9@output_str:

; 194  : 
; 195  :     return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@output_str:

; 196  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_output_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _int64_str
_TEXT	SEGMENT
tv83 = -220						; size = 4
_j$ = -20						; size = 4
_p$ = -8						; size = 4
_s$ = 8							; size = 4
_size$ = 12						; size = 4
_i$ = 16						; size = 8
_base$ = 24						; size = 4
_upcase$ = 28						; size = 1
_int64_str PROC						; COMDAT

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 87   :     char *p;
; 88   :     unsigned int j = 0;

	mov	DWORD PTR _j$[ebp], 0

; 89   :     
; 90   :     s[--size] = 0; 

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR _size$[ebp]
	mov	BYTE PTR [ecx], 0

; 91   :     
; 92   :     p = s + size;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 93   :     
; 94   :     if (base == 0 || base > 36) 

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN5@int64_str
	cmp	DWORD PTR _base$[ebp], 36		; 00000024H
	jle	SHORT $LN4@int64_str
$LN5@int64_str:

; 95   :         base = 10;

	mov	DWORD PTR _base$[ebp], 10		; 0000000aH
$LN4@int64_str:

; 96   :     
; 97   :     j = 0;

	mov	DWORD PTR _j$[ebp], 0

; 98   :     if (i == 0) {

	mov	eax, DWORD PTR _i$[ebp]
	or	eax, DWORD PTR _i$[ebp+4]
	jne	SHORT $LN2@int64_str

; 99   :         *(--p) = '0';

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx], 48			; 00000030H

; 100  :         j = 1;

	mov	DWORD PTR _j$[ebp], 1
$LN2@int64_str:

; 101  :     }
; 102  :     
; 103  :     while (p > s && i != 0) {

	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _s$[ebp]
	jbe	$LN3@int64_str
	mov	eax, DWORD PTR _i$[ebp]
	or	eax, DWORD PTR _i$[ebp+4]
	je	$LN3@int64_str

; 104  :         p--;

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 105  :         *p = (char)(i % base + '0');

	mov	eax, DWORD PTR _base$[ebp]
	cdq
	push	edx
	push	eax
	mov	eax, DWORD PTR _i$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	__aullrem
	add	eax, 48					; 00000030H
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], al

; 106  :         if (*p > '9') 

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN7@int64_str

; 107  :             *p += (upcase ? 'A' : 'a') - '9' - 1;

	movsx	eax, BYTE PTR _upcase$[ebp]
	test	eax, eax
	je	SHORT $LN9@int64_str
	mov	DWORD PTR tv83[ebp], 65			; 00000041H
	jmp	SHORT $LN10@int64_str
$LN9@int64_str:
	mov	DWORD PTR tv83[ebp], 97			; 00000061H
$LN10@int64_str:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR tv83[ebp]
	lea	ecx, DWORD PTR [edx+eax-58]
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], cl
$LN7@int64_str:

; 108  :         i /= base;

	mov	eax, DWORD PTR _base$[ebp]
	cdq
	push	edx
	push	eax
	mov	eax, DWORD PTR _i$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	__aulldiv
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _i$[ebp+4], edx

; 109  :         j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 110  :     }

	jmp	$LN2@int64_str
$LN3@int64_str:

; 111  : 
; 112  :     memmove(s, p, j + 1);

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 113  : 
; 114  :     return j;

	mov	eax, DWORD PTR _j$[ebp]

; 115  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_int64_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _write_pad
_TEXT	SEGMENT
_n$ = -20						; size = 4
_pad$ = -8						; size = 4
_len$ = 8						; size = 4
_pad_ch$ = 12						; size = 4
_write_pad PROC						; COMDAT

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 65   :     const char *pad;
; 66   :     size_t n;
; 67   : 
; 68   :     if ((int)len <= 0) 

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN5@write_pad

; 69   :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@write_pad
$LN5@write_pad:

; 70   : 
; 71   :     if (pad_ch == '0')

	cmp	DWORD PTR _pad_ch$[ebp], 48		; 00000030H
	jne	SHORT $LN6@write_pad

; 72   :         pad = "0000000000000000";

	mov	DWORD PTR _pad$[ebp], OFFSET ??_C@_0BB@GHIALFFI@0000000000000000@
	jmp	SHORT $LN7@write_pad
$LN6@write_pad:

; 73   :     else
; 74   :         pad = "                ";

	mov	DWORD PTR _pad$[ebp], OFFSET ??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
$LN7@write_pad:

; 75   : 
; 76   :     for (n = 0; len > 15; len -= 16, n += 16) 

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@write_pad
$LN2@write_pad:
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], ecx
$LN4@write_pad:
	cmp	DWORD PTR _len$[ebp], 15		; 0000000fH
	jbe	SHORT $LN3@write_pad

; 77   :         output(pad, 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _pad$[ebp]
	push	eax
	call	_output
	add	esp, 8
	jmp	SHORT $LN2@write_pad
$LN3@write_pad:

; 78   : 
; 79   :     if (len > 0) 

	cmp	DWORD PTR _len$[ebp], 0
	jbe	SHORT $LN8@write_pad

; 80   :         n += output(pad, len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pad$[ebp]
	push	ecx
	call	_output
	add	esp, 8
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], eax
$LN8@write_pad:

; 81   : 
; 82   :     return n;

	mov	eax, DWORD PTR _n$[ebp]
$LN1@write_pad:

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_write_pad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _output
_TEXT	SEGMENT
tv71 = -304						; size = 4
tv144 = -300						; size = 4
tv70 = -300						; size = 4
_end$ = -100						; size = 4
_tail$ = -88						; size = 4
_head$ = -76						; size = 4
_timestamp$ = -64					; size = 32
_n$ = -24						; size = 4
_ms$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_output	PROC						; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 45   : 	static bool sol = true; /* start of line */
; 46   : 	unsigned int ms, n;
; 47   : 	char timestamp[32];
; 48   : 	const char *head, *tail, *end = str + len;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 49   : 
; 50   : 	for (head = tail = str; tail < end; head = tail) {

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _tail$[ebp], eax
	mov	ecx, DWORD PTR _tail$[ebp]
	mov	DWORD PTR _head$[ebp], ecx
	jmp	SHORT $LN4@output
$LN2@output:
	mov	eax, DWORD PTR _tail$[ebp]
	mov	DWORD PTR _head$[ebp], eax
$LN4@output:
	mov	eax, DWORD PTR _tail$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	$LN3@output
$LN5@output:

; 51   : 		while (tail < end && *tail++ != '\n');

	mov	eax, DWORD PTR _tail$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	SHORT $LN6@output
	mov	eax, DWORD PTR _tail$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv70[ebp], ecx
	mov	edx, DWORD PTR _tail$[ebp]
	add	edx, 1
	mov	DWORD PTR _tail$[ebp], edx
	cmp	DWORD PTR tv70[ebp], 10			; 0000000aH
	je	SHORT $LN17@output
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN18@output
$LN17@output:
	mov	DWORD PTR tv71[ebp], 0
$LN18@output:
	cmp	DWORD PTR tv71[ebp], 0
	je	SHORT $LN6@output
	jmp	SHORT $LN5@output
$LN6@output:

; 52   : 		if (sol) {

	cmp	DWORD PTR ?sol@?1??output@@9@9, 0
	je	$LN12@output

; 53   : 			ms = get_ms();

	call	_get_ms
	mov	DWORD PTR _ms$[ebp], eax

; 54   : 			n = sprintf(timestamp, "%03d.%03d ", ms / 1000, ms % 1000);

	mov	eax, DWORD PTR _ms$[ebp]
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	push	eax
	push	OFFSET ??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
	lea	edx, DWORD PTR _timestamp$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], eax
$LN9@output:

; 55   : 			tee_output(timestamp, n);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _timestamp$[ebp]
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _log_file, 0
	je	SHORT $LN7@output
	mov	esi, esp
	mov	eax, DWORD PTR _log_file
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR _timestamp$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@output:
	xor	eax, eax
	jne	SHORT $LN9@output
$LN12@output:

; 56   : 		}
; 57   : 		tee_output(head, tail - head);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _tail$[ebp]
	sub	eax, DWORD PTR _head$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _head$[ebp]
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _log_file, 0
	je	SHORT $LN10@output
	mov	esi, esp
	mov	eax, DWORD PTR _log_file
	push	eax
	mov	ecx, DWORD PTR _tail$[ebp]
	sub	ecx, DWORD PTR _head$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _head$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@output:
	xor	eax, eax
	jne	SHORT $LN12@output

; 58   : 		sol = tail[-1] == '\n';

	mov	eax, 1
	imul	ecx, eax, -1
	mov	edx, DWORD PTR _tail$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN19@output
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN20@output
$LN19@output:
	mov	DWORD PTR tv144[ebp], 0
$LN20@output:
	mov	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR ?sol@?1??output@@9@9, ecx

; 59   : 	}

	jmp	$LN2@output
$LN3@output:

; 60   : 	return len;

	mov	eax, DWORD PTR _len$[ebp]

; 61   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@output
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@output:
	DD	1
	DD	$LN22@output
$LN22@output:
	DD	-64					; ffffffc0H
	DD	32					; 00000020H
	DD	$LN21@output
$LN21@output:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_output	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _skip_to
_TEXT	SEGMENT
_i$ = -8						; size = 4
_format$ = 8						; size = 4
_skip_to PROC						; COMDAT

; 31   : static unsigned long skip_to(const char *format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 32   :     unsigned long i;
; 33   :     for (i = 0; format[i] && format[i] != '%'; ++i);

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@skip_to
$LN2@skip_to:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@skip_to:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@skip_to
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	je	SHORT $LN3@skip_to
	jmp	SHORT $LN2@skip_to
$LN3@skip_to:

; 34   :     return i;

	mov	eax, DWORD PTR _i$[ebp]

; 35   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_skip_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT ___v_lprintf
_TEXT	SEGMENT
tv80 = -388						; size = 4
tv187 = -384						; size = 4
tv162 = -384						; size = 4
tv149 = -384						; size = 4
tv79 = -384						; size = 4
_prefix$ = -184						; size = 4
_num$ = -172						; size = 8
_precision$ = -156					; size = 4
_width$ = -144						; size = 4
_base$ = -132						; size = 4
_opt_long$ = -120					; size = 4
_pad$ = -105						; size = 1
_ch$ = -93						; size = 1
_flag$ = -84						; size = 4
_ptr$ = -72						; size = 4
_s$ = -60						; size = 4
_err$ = -48						; size = 4
_n$ = -36						; size = 4
_l$ = -24						; size = 4
_len$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_arg_ptr$ = 12						; size = 4
___v_lprintf PROC					; COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 364  :     size_t len = 0, l;

	mov	DWORD PTR _len$[ebp], 0

; 365  :     signed int n;
; 366  :     int err = errno;

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _err$[ebp], eax
$LN73@v_lprintf:

; 367  :     char *s;
; 368  :     unsigned char *ptr;
; 369  :     int flag;
; 370  :     char ch, pad;
; 371  :     
; 372  :     signed int opt_long;
; 373  : 
; 374  :     unsigned int base;
; 375  :     size_t width, precision;
; 376  :     
; 377  :     __int64 num;
; 378  :     char *prefix;
; 379  : 
; 380  :     while (*format) {

	mov	eax, DWORD PTR _format$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@v_lprintf

; 381  :         
; 382  :         n = skip_to(format);

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	_skip_to
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 383  :         if (n) {

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN6@v_lprintf

; 384  :             output(format, n); 

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	call	_output
	add	esp, 8

; 385  :             len += n;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 386  :             format += n;

	mov	eax, DWORD PTR _format$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _format$[ebp], eax
$LN6@v_lprintf:

; 387  :         }
; 388  :         
; 389  :         if (*format != '%') 

	mov	eax, DWORD PTR _format$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	je	SHORT $LN7@v_lprintf

; 390  :             continue;

	jmp	SHORT $LN73@v_lprintf
$LN7@v_lprintf:

; 391  :         
; 392  :         pad = ' ';

	mov	BYTE PTR _pad$[ebp], 32			; 00000020H

; 393  :         flag = 0;

	mov	DWORD PTR _flag$[ebp], 0

; 394  :         opt_long = 0;

	mov	DWORD PTR _opt_long$[ebp], 0

; 395  :         prefix = "";

	mov	DWORD PTR _prefix$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 396  :         
; 397  :         width = 0;

	mov	DWORD PTR _width$[ebp], 0

; 398  :         precision = 0;

	mov	DWORD PTR _precision$[ebp], 0

; 399  :         num = 0;

	xorps	xmm0, xmm0
	movlpd	QWORD PTR _num$[ebp], xmm0

; 400  :         
; 401  :         ++format;

	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 1
	mov	DWORD PTR _format$[ebp], eax
$next_option$88:

; 402  :         
; 403  : next_option:
; 404  :         switch (ch = *format++) {

	mov	eax, DWORD PTR _format$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	movsx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 1
	mov	DWORD PTR _format$[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 122		; 0000007aH
	ja	$LN65@v_lprintf
	mov	edx, DWORD PTR tv80[ebp]
	movzx	eax, BYTE PTR $LN82@v_lprintf[edx]
	jmp	DWORD PTR $LN83@v_lprintf[eax*4]
$LN8@v_lprintf:

; 405  :         case 0:
; 406  :             return -1;

	or	eax, -1
	jmp	$LN1@v_lprintf

; 407  :             break;

	jmp	$LN4@v_lprintf
$LN9@v_lprintf:

; 408  :             
; 409  :         /* FLAGS */
; 410  :         case '#':
; 411  :             flag |= F_HASH;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 4
	mov	DWORD PTR _flag$[ebp], eax

; 412  :             goto next_option;

	jmp	SHORT $next_option$88
$LN10@v_lprintf:

; 413  : 
; 414  :         case 'h':
; 415  :             --opt_long;

	mov	eax, DWORD PTR _opt_long$[ebp]
	sub	eax, 1
	mov	DWORD PTR _opt_long$[ebp], eax

; 416  :             goto next_option;

	jmp	SHORT $next_option$88
$LN11@v_lprintf:

; 417  :             
; 418  :         case 'q':     
; 419  :         case 'L':
; 420  :             ++opt_long;

	mov	eax, DWORD PTR _opt_long$[ebp]
	add	eax, 1
	mov	DWORD PTR _opt_long$[ebp], eax
$LN13@v_lprintf:

; 421  :         case 'z':
; 422  :         case 'l':
; 423  :             ++opt_long;

	mov	eax, DWORD PTR _opt_long$[ebp]
	add	eax, 1
	mov	DWORD PTR _opt_long$[ebp], eax

; 424  :             goto next_option;

	jmp	SHORT $next_option$88
$LN15@v_lprintf:

; 425  :             
; 426  :         case '-':
; 427  :             flag |= F_LEFT;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 8
	mov	DWORD PTR _flag$[ebp], eax

; 428  :             goto next_option;

	jmp	$next_option$88
$LN16@v_lprintf:

; 429  :             
; 430  :         case ' ':
; 431  :             flag |= F_SPACE;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _flag$[ebp], eax

; 432  :             goto next_option;

	jmp	$next_option$88
$LN17@v_lprintf:

; 433  :             
; 434  :         case '+':
; 435  :             flag |= F_PLUS;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _flag$[ebp], eax

; 436  :             goto next_option;

	jmp	$next_option$88
$LN18@v_lprintf:

; 437  :             
; 438  :         case '0':
; 439  :         case '1':
; 440  :         case '2':
; 441  :         case '3':
; 442  :         case '4':
; 443  :         case '5':
; 444  :         case '6':
; 445  :         case '7':
; 446  :         case '8':
; 447  :         case '9':
; 448  :             if (flag & F_DOT) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN28@v_lprintf

; 449  :                 return -1;

	or	eax, -1
	jmp	$LN1@v_lprintf
$LN28@v_lprintf:

; 450  :             width = strtoul(format - 1, (char **)&s, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	sub	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _width$[ebp], eax

; 451  :             if (width > MAX_WIDTH) 

	cmp	DWORD PTR _width$[ebp], 10240		; 00002800H
	jbe	SHORT $LN29@v_lprintf

; 452  :                 return -1;

	or	eax, -1
	jmp	$LN1@v_lprintf
$LN29@v_lprintf:

; 453  :             if (ch == '0' && !(flag & F_LEFT)) 

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN30@v_lprintf
	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 8
	jne	SHORT $LN30@v_lprintf

; 454  :                 pad = '0';

	mov	BYTE PTR _pad$[ebp], 48			; 00000030H
$LN30@v_lprintf:

; 455  :             format = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _format$[ebp], eax

; 456  :             goto next_option;

	jmp	$next_option$88
$LN31@v_lprintf:

; 457  :             
; 458  :         case '*': 
; 459  :             if ((n = va_arg(arg_ptr, int)) < 0) {

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _n$[ebp], edx
	cmp	DWORD PTR _n$[ebp], 0
	jge	SHORT $LN32@v_lprintf

; 460  :                 flag |= F_LEFT;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 8
	mov	DWORD PTR _flag$[ebp], eax

; 461  :                 n = -n;

	mov	eax, DWORD PTR _n$[ebp]
	neg	eax
	mov	DWORD PTR _n$[ebp], eax
$LN32@v_lprintf:

; 462  :             }
; 463  :             if ((width = (unsigned long)n) > MAX_WIDTH) 

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _width$[ebp], eax
	cmp	DWORD PTR _width$[ebp], 10240		; 00002800H
	jbe	SHORT $LN33@v_lprintf

; 464  :                 return -1;

	or	eax, -1
	jmp	$LN1@v_lprintf
$LN33@v_lprintf:

; 465  :             goto next_option; 

	jmp	$next_option$88
$LN34@v_lprintf:

; 466  :             
; 467  :         case '.':
; 468  :             flag |= F_DOT;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _flag$[ebp], eax

; 469  :             if (*format == '*') {

	mov	eax, DWORD PTR _format$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN35@v_lprintf

; 470  :                 n = va_arg(arg_ptr, int);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _n$[ebp], edx

; 471  :                 ++format;

	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 1
	mov	DWORD PTR _format$[ebp], eax

; 472  :             } else {

	jmp	SHORT $LN36@v_lprintf
$LN35@v_lprintf:

; 473  :                 n = strtol(format, (char**)&s, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$[ebp], eax

; 474  :                 format = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _format$[ebp], eax
$LN36@v_lprintf:

; 475  :             }
; 476  :             precision = n < 0 ? 0 : n;

	cmp	DWORD PTR _n$[ebp], 0
	jge	SHORT $LN67@v_lprintf
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN68@v_lprintf
$LN67@v_lprintf:
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv149[ebp], eax
$LN68@v_lprintf:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _precision$[ebp], ecx

; 477  :             if (precision > MAX_WIDTH) 

	cmp	DWORD PTR _precision$[ebp], 10240	; 00002800H
	jbe	SHORT $LN37@v_lprintf

; 478  :                 return -1;

	or	eax, -1
	jmp	$LN1@v_lprintf
$LN37@v_lprintf:

; 479  :             goto next_option;

	jmp	$next_option$88
$LN38@v_lprintf:

; 480  :             
; 481  :         /* print a char or % */
; 482  :         case 'c':
; 483  :             ch = (char)va_arg(arg_ptr, int);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	dl, BYTE PTR [ecx-4]
	mov	BYTE PTR _ch$[ebp], dl
$LN39@v_lprintf:

; 484  :         case '%':
; 485  :             output(&ch, 1); 

	push	1
	lea	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_output
	add	esp, 8

; 486  :             ++len;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 487  :             break;

	jmp	$LN4@v_lprintf
$LN40@v_lprintf:

; 488  :                        
; 489  :         /* print a string */
; 490  :         case 'm':
; 491  :         case 's':
; 492  :             s = ch == 'm' ? strerror(err) : va_arg(arg_ptr, char *);

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN69@v_lprintf
	mov	esi, esp
	mov	ecx, DWORD PTR _err$[ebp]
	push	ecx
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN70@v_lprintf
$LN69@v_lprintf:
	mov	edx, DWORD PTR _arg_ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _arg_ptr$[ebp], edx
	mov	eax, DWORD PTR _arg_ptr$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR tv162[ebp], ecx
$LN70@v_lprintf:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR _s$[ebp], edx

; 493  :             if (s == NULL) 

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN42@v_lprintf

; 494  :                 s = "(null)";

	mov	DWORD PTR _s$[ebp], OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ@
$LN42@v_lprintf:

; 495  :             l = strlen(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 496  :             if ((flag & F_DOT) && l > precision) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN43@v_lprintf
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _precision$[ebp]
	jbe	SHORT $LN43@v_lprintf

; 497  :                 l = precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN43@v_lprintf:

; 498  :             flag &= ~F_DOT;

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _flag$[ebp], eax

; 499  :             len += output_string(s, l, 0, width, 0, flag, ' ', ' ');

	push	32					; 00000020H
	push	32					; 00000020H
	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_output_string
	add	esp, 32					; 00000020H
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 500  :             break;

	jmp	$LN4@v_lprintf
$LN44@v_lprintf:

; 501  :              
; 502  :         /* print an integer value */
; 503  :         case 'b':
; 504  :             base = 2;

	mov	DWORD PTR _base$[ebp], 2

; 505  :             goto print_num;

	jmp	$print_num$89
$LN45@v_lprintf:

; 506  :             
; 507  :         case 'p':
; 508  :             prefix = "0x";

	mov	DWORD PTR _prefix$[ebp], OFFSET ??_C@_02MDDDDAID@0x@

; 509  :             opt_long = sizeof(void *) / sizeof(long);

	mov	DWORD PTR _opt_long$[ebp], 1
$LN46@v_lprintf:

; 510  :         case 'X':
; 511  :             if (ch == 'X')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN47@v_lprintf

; 512  :                 flag |= F_UPCASE;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 2
	mov	DWORD PTR _flag$[ebp], eax
$LN47@v_lprintf:

; 513  :         case 'x':
; 514  :             base = 16;

	mov	DWORD PTR _base$[ebp], 16		; 00000010H

; 515  :             if (flag & F_HASH) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 4
	je	SHORT $LN49@v_lprintf

; 516  :                 prefix = ch == 'X' ? "0X" : "0x";

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN71@v_lprintf
	mov	DWORD PTR tv187[ebp], OFFSET ??_C@_02FGLHBECB@0X@
	jmp	SHORT $LN72@v_lprintf
$LN71@v_lprintf:
	mov	DWORD PTR tv187[ebp], OFFSET ??_C@_02MDDDDAID@0x@
$LN72@v_lprintf:
	mov	ecx, DWORD PTR tv187[ebp]
	mov	DWORD PTR _prefix$[ebp], ecx
$LN49@v_lprintf:

; 517  :             goto print_num;

	jmp	SHORT $print_num$89
$LN50@v_lprintf:

; 518  :             
; 519  :         case 'd':
; 520  :         case 'i': 
; 521  :             flag |= F_SIGN;

	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 1
	mov	DWORD PTR _flag$[ebp], eax
$LN52@v_lprintf:

; 522  :         case 'u':
; 523  :             base = 10;

	mov	DWORD PTR _base$[ebp], 10		; 0000000aH

; 524  :             goto print_num;

	jmp	SHORT $print_num$89
$LN53@v_lprintf:

; 525  :             
; 526  :         case 'o':
; 527  :             base = 8;

	mov	DWORD PTR _base$[ebp], 8

; 528  :             if (flag & F_HASH) 

	mov	eax, DWORD PTR _flag$[ebp]
	and	eax, 4
	je	SHORT $print_num$89

; 529  :                 prefix = "0";

	mov	DWORD PTR _prefix$[ebp], OFFSET ??_C@_01GBGANLPD@0@
$print_num$89:

; 530  : print_num:
; 531  :             if (opt_long > 0) {

	cmp	DWORD PTR _opt_long$[ebp], 0
	jle	SHORT $LN55@v_lprintf

; 532  :                 if (opt_long > 1)

	cmp	DWORD PTR _opt_long$[ebp], 1
	jle	SHORT $LN57@v_lprintf

; 533  :                     num = va_arg(arg_ptr, __int64);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 8
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	edx, DWORD PTR [ecx-8]
	mov	eax, DWORD PTR [ecx-4]
	mov	DWORD PTR _num$[ebp], edx
	mov	DWORD PTR _num$[ebp+4], eax
	jmp	SHORT $LN58@v_lprintf
$LN57@v_lprintf:

; 534  :                 else
; 535  :                     num = (__int64)va_arg(arg_ptr, long);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	eax, DWORD PTR [ecx-4]
	cdq
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], edx
$LN58@v_lprintf:

; 536  :             } else 

	jmp	SHORT $LN56@v_lprintf
$LN55@v_lprintf:

; 537  :                 num = (__int64)va_arg(arg_ptr, int);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	eax, DWORD PTR [ecx-4]
	cdq
	mov	DWORD PTR _num$[ebp], eax
	mov	DWORD PTR _num$[ebp+4], edx
$LN56@v_lprintf:

; 538  : 
; 539  :             len += output_integer(num, opt_long, ch, 

	movzx	eax, BYTE PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _opt_long$[ebp]
	push	ecx
	mov	edx, DWORD PTR _num$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	call	_output_integer
	add	esp, 40					; 00000028H
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 540  :                 width, precision, flag, base, prefix, pad);
; 541  :             break;

	jmp	$LN4@v_lprintf
$LN59@v_lprintf:

; 542  :   
; 543  :         /* print a floating point value */
; 544  :         case 'g':
; 545  :         case 'F':  
; 546  :         case 'f':
; 547  :         case 'e':
; 548  :         case 'E':
; 549  :             len += output_double(va_arg(arg_ptr, double), ch, 

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 8
	mov	DWORD PTR _arg_ptr$[ebp], eax
	movsx	ecx, BYTE PTR _pad$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flag$[ebp]
	push	edx
	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _ch$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg_ptr$[ebp]
	movsd	xmm0, QWORD PTR [eax-8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_output_double
	add	esp, 28					; 0000001cH
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 550  :                 width, precision, flag, pad);
; 551  :             break;

	jmp	SHORT $LN4@v_lprintf
$LN64@v_lprintf:

; 552  : 
; 553  :         /* print a memory block */
; 554  :         case 'M': 
; 555  :             ptr = va_arg(arg_ptr, unsigned char *);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	mov	ecx, DWORD PTR _arg_ptr$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _ptr$[ebp], edx

; 556  :             len += output_memory_block(ptr, va_arg(arg_ptr, int), 

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _arg_ptr$[ebp], eax
	movsx	ecx, BYTE PTR _pad$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flag$[ebp]
	push	edx
	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _arg_ptr$[ebp]
	mov	eax, DWORD PTR [edx-4]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_output_memory_block
	add	esp, 24					; 00000018H
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN65@v_lprintf:
$LN4@v_lprintf:

; 557  :                 width, precision, flag, pad); 
; 558  :             break; 
; 559  : 
; 560  :         default:
; 561  :             break;
; 562  :         }
; 563  :     }

	jmp	$LN73@v_lprintf
$LN3@v_lprintf:

; 564  :     return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@v_lprintf:

; 565  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN87@v_lprintf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN87@v_lprintf:
	DD	2
	DD	$LN86@v_lprintf
$LN86@v_lprintf:
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN84@v_lprintf
	DD	-93					; ffffffa3H
	DD	1
	DD	$LN85@v_lprintf
$LN85@v_lprintf:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	0
$LN84@v_lprintf:
	DB	115					; 00000073H
	DB	0
	npad	3
$LN83@v_lprintf:
	DD	$LN8@v_lprintf
	DD	$LN16@v_lprintf
	DD	$LN9@v_lprintf
	DD	$LN39@v_lprintf
	DD	$LN31@v_lprintf
	DD	$LN17@v_lprintf
	DD	$LN15@v_lprintf
	DD	$LN34@v_lprintf
	DD	$LN18@v_lprintf
	DD	$LN59@v_lprintf
	DD	$LN11@v_lprintf
	DD	$LN64@v_lprintf
	DD	$LN46@v_lprintf
	DD	$LN44@v_lprintf
	DD	$LN38@v_lprintf
	DD	$LN50@v_lprintf
	DD	$LN10@v_lprintf
	DD	$LN13@v_lprintf
	DD	$LN40@v_lprintf
	DD	$LN53@v_lprintf
	DD	$LN45@v_lprintf
	DD	$LN52@v_lprintf
	DD	$LN47@v_lprintf
	DD	$LN65@v_lprintf
$LN82@v_lprintf:
	DB	0
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	1
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	2
	DB	23					; 00000017H
	DB	3
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	4
	DB	5
	DB	23					; 00000017H
	DB	6
	DB	7
	DB	23					; 00000017H
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	9
	DB	9
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	12					; 0000000cH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	9
	DB	9
	DB	9
	DB	16					; 00000010H
	DB	15					; 0000000fH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	23					; 00000017H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	10					; 0000000aH
	DB	23					; 00000017H
	DB	18					; 00000012H
	DB	23					; 00000017H
	DB	21					; 00000015H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	17					; 00000011H
___v_lprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Documents\桌面\计算机网络实验\Lab1-2022(Win+Linux)\selective\lprintf.c
;	COMDAT _lprintf
_TEXT	SEGMENT
_arg_ptr$ = -20						; size = 4
_n$ = -8						; size = 4
_format$ = 8						; size = 4
_lprintf PROC						; COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __068A3847_lprintf@c
	call	@__CheckForDebuggerJustMyCode@4

; 569  :     size_t n;
; 570  :     va_list arg_ptr;
; 571  : 
; 572  :     va_start(arg_ptr, format);

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _arg_ptr$[ebp], eax

; 573  : 	n = __v_lprintf(format, arg_ptr);

	mov	eax, DWORD PTR _arg_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	call	___v_lprintf
	add	esp, 8
	mov	DWORD PTR _n$[ebp], eax

; 574  :     va_end(arg_ptr);

	mov	DWORD PTR _arg_ptr$[ebp], 0

; 575  : 
; 576  :     return n;

	mov	eax, DWORD PTR _n$[ebp]

; 577  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_lprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1780 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1460 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1392 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1397 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A2143F22_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
